# 链表

#### 双指针

##### 有序合并

```java
ListNode mergeTwoLists(ListNode l1, ListNode l2) {
  ListNode dummy = new ListNode(-1), p = dummy;
  ListNode p1 = l1, p2 = l2;
  
  while(p1 != null && p2 != null){
  	if(p1.val < p2.val)  
    	p.next = p1;
    	p1 = p1.next;
        
  	}else{
    	p.next = p2;
    	p2 = p2.next;
  	}
  p = p.next;
  }

	//最后都弄完了，还有个链有剩余
	if (p1 != null){
    p.next = p1;
  }
	if (p2 != null){
    p.next = p2;
  }

	return dummy.next;
}
```



##### 分割链表

```java
ListNode partition(ListNode head, int x) {
  //存放小于的
  ListNode dummy1 = new ListNode(-1);
  //存放大于的
  ListNode dummy2 = new ListNode(-1);
  //两个指针负责生成结果链表
  ListNode p1 = dummy1, p2 = dummy2;
  //p遍历原链表
  ListNode p = head;
  
  while (p != null){
    if (p.val >= x){
      p2.next = p;
      p2 = p2.next;
    }else{
      p1.next = p;
      p1 = p1.next;
    }
    //断开原来链表每个节点的next指针
    //暂时记录p后面一位
    ListNode temp = p.next;
    p.next = null;
    p = temp // 意思是待处理的节点p，后移
  }
  
  p1.next = dummy2.next;
  
  return dummy1.next;
}


```



##### 合并k个有序链表

```java
//合并k个有序链表
//二叉堆、优先级队列：为了方便的获得每次的最小值
ListNode mergeKLists(ListNode[] lists){
  ListNode dummy = new ListNode(-1);
  ListNode p = dummy;
  
  PriorityQueue<ListNode> pq = new PriorityQuery<>(
  	lists.length, (a, b) -> (a.val - b.val));
  
  for (ListNode head : lists){
    if (head != null)
      pq.add(head);
  }
  
  while (!pq.isEmpty()){
    ListNode node = pq.roll();
    p.next = node;
    if (node.next != null){
      pq.add(node.next);
    }
    p = p.next;
    
  }
  return dummy.next
  
}


```

