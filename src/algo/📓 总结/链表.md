# 链表

### 双指针

#### 有序合并

```java
ListNode mergeTwoLists(ListNode l1, ListNode l2) {
  ListNode dummy = new ListNode(-1), p = dummy;
  ListNode p1 = l1, p2 = l2;
  
  while(p1 != null && p2 != null){
  	if(p1.val < p2.val)  
    	p.next = p1;
    	p1 = p1.next;
        
  	}else{
    	p.next = p2;
    	p2 = p2.next;
  	}
  p = p.next;
  }

	//最后都弄完了，还有个链有剩余
	if (p1 != null){
    p.next = p1;
  }
	if (p2 != null){
    p.next = p2;
  }

	return dummy.next;
}
```



#### 分割链表

```java
ListNode partition(ListNode head, int x) {
  //存放小于的
  ListNode dummy1 = new ListNode(-1);
  //存放大于的
  ListNode dummy2 = new ListNode(-1);
  //两个指针负责生成结果链表
  ListNode p1 = dummy1, p2 = dummy2;
  //p遍历原链表
  ListNode p = head;
  
  while (p != null){
    if (p.val >= x){
      p2.next = p;
      p2 = p2.next;
    }else{
      p1.next = p;
      p1 = p1.next;
    }
    //断开原来链表每个节点的next指针
    //暂时记录p后面一位
    ListNode temp = p.next;
    p.next = null;
    p = temp // 意思是待处理的节点p，后移
  }
  
  p1.next = dummy2.next;
  
  return dummy1.next;
}
```



#### 合并k个有序链表

```java
//合并k个有序链表
//二叉堆、优先级队列：为了方便的获得每次的最小值
ListNode mergeKLists(ListNode[] lists){
  ListNode dummy = new ListNode(-1);
  ListNode p = dummy;
  
  PriorityQueue<ListNode> pq = new PriorityQuery<>(
  	lists.length, (a, b) -> (a.val - b.val));
  
  for (ListNode head : lists){
    if (head != null)
      pq.add(head);
  }
  
  while (!pq.isEmpty()){
    ListNode node = pq.roll();
    p.next = node;
    if (node.next != null){
      pq.add(node.next);
    }
    p = p.next;
    
  }
  return dummy.next
  
}


```

时间复杂度：优先队列中的元素个数最多是`k`（链表条数），所以一次`poll`或`add`方法的时间复杂度是`o(logk)`，算法整体的时间复杂度`o(Nlogk)`，N是链表的节点总数。



#### 单链表的倒数第k个节点

##### 基本方法

1. 让一个指针p1指向头节点head，走k步
2. 此时再用一个节点p2，指向头节点head
3. p1，p2同时走，走到链表末尾的空指针时，p1走了n-k步，p2从head开始走了n-k步，正好停留在倒数第k上

```java
ListNode findFromEnd(ListNode head, int k){
  ListNode p1 = head;
  
  for (int i = 0; i < k; i++){
    p1 = p1.next;
  }
  ListNode p2 = head;
  
  while (p1 != null){
    p2 = p2.next;
    p1 = p1.next;
  }
  return p2;
}
```



##### 删除倒数第k个

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
  //需要找到倒数n+1
  ListNode dummy = new ListNode(-1);
  dummy.next = head;
  ListNode x = findFromEnd(dummy, n + 1);
  x.next = x.next.next;
  return dummy.next;
}

private ListNode findFromEnd(ListNode head, int k){
  ListNode p1 = head;
  
  for(int i = 0; i < k; i++){
    p1 = p1.next;
  }
  
  ListNode p2 = head;
  while( p1 != null){
    p1 = p1.next
    p2 = p2.next
  }
  return p2;
}

```

⚠️此处为了防止空指针，引入虚拟头节点（有+1的操作，节点也+1）