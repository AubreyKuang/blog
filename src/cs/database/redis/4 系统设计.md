# 系统设计



## 热点信息

在设计和开发时已经极力避免，然而在真实的生产环境中还是可能依旧存在的，导致其继续出现的原因有以下几种:

- 有一些边界 case 没有考虑到
- 异常或非预期的流量

### 定位方案

从 Redis 请求路径上的节点来着手，比如在客户端、中间层和服务端

#### 客户端

改动 Redis SDK，记录每个请求，定时把收集到的数据上报，然后由一个统一的服务进行聚合计算。

方案直观简单，但没法适应多语言架构，一方面多语言 SDK 对齐是个问题，另外一方面后期 SDK 的维护升级会面临比较大的困难，成本很高。

#### 中间层

如果所有的 Redis 请求都经过代理的话，可以考虑改动 Proxy 代码进行收集，思路与客户端基本类似。该方案对使用方完全透明，能够解决客户端 SDK 的语言异构和版本升级问题，不过开发成本会比客户端高些。

#### 服务端

在可能存在热 key 的节点上(流量倾斜判断)，通过 tcpdump 抓取一段时间内的流量并上报，然后由一个外部的程序进行解析、聚合和计算。该方案无需侵入现有的 SDK 或者 Proxy 中间件，开发维护成本可控，但也存在缺点的，具体是热 key 节点的网络流量和系统负载已经比较高了，抓包可能会情况进一步恶化。



### 如何处理热点

放在缓存中，最好可以写入 jvm （因为 jvm 中数据访问速度最快，几乎不存在网络开销），并且设置过期时间。

不宜写入太多，避免内存占用过大，要设置淘汰策略。



## 静态资源

CDN（Content Delivery Network）内容分发网络

将静态资源分发到多个不同的地方以实现就近访问，加快静态资源的访问速度，减轻服务器及带宽的负担。



## 高可用

保证系统中某个组件的高可用，往往需要搭建集群来避免单点风险，以 Redis 集群为例：

通过 异步复制，**一主多从** 来提高可用性和读吞吐量

问题：一旦 master 宕机，slave 晋升成 master，同时需要修改应用方的主节点地址，还需要命令所有从节点复制新的主节点。

解决：通过哨兵解决，监控 Redis 运行节点，当主节点故障，哨兵节点会帮助我们实现故障转移。整个过程完全自动，不需要人工介入

> 哨兵其实是一个 Rdis 进程，只是不对外提供读写服务。





### 限流

接口限流：限制服务端的接口接受请求的频率

实现：可以直接用 Redis 基于 Lua 脚本做，也可以用现成的流量控制组件。组件往往会提供一些流量控制、熔断降级、系统自适应保护等功能。

用户、IP 限流：限制单位时间内请求接口的次数

> 设置问题或者验证码，出了校验答案的正确性，还要校验用户的提交时间





### 流量削峰

对于突发的大流量，可以用消息队列

因为消息可以大量堆积在消息队列



### 服务降级

从系统功能优先级的角度考虑应对系统故障

根据当前业务情况、流量对一些服务和页面有策略地降级，释放服务器资源以保证核心业务的正常运行。

> 应对系统自身的故障

### 熔断

应对系统依赖的外部系统或者第三方系统的故障



## 一致性

### 减库存方案

下单即减库存

将秒杀商品的信息放到缓存中去，通过 Redis 对库存进行原子性操作



### 接口幂等性

在分布式系统中，幂等是对请求操作结果的描述，就是不论执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求一样。

前端要做、后端也要做

前端：当用户提交请求后将按钮变灰

后端：同步锁、分布式锁、业务字段唯一索引约束

> 分布式锁：加锁的方式，限制用户在第一次请求未结束之前，无法进行第二次请求







## Feed 流 / 信息流

TimeLine 时期，基于时间

现在的 Feed 流主要基于个性化推荐

### Feed 流

实时 / 智能推送信息的数据流，朋友圈动态、平台推荐等都属于 Feed 流

#### 三种形式

1. 纯智能推荐，依赖推荐系统
2. 时间线，微信朋友圈
3. 智能推荐 + 时间线



#### 三种推送模式

推模式：博主更新后，推给粉丝

拉模式：自己拉取动态

> 虽然拉模式的存储成本低，但是查询和聚合的成本高。实时性比推模式差

推拉结合：微博大 V 和不活跃用户

> 适用于用户粉丝数大的场景
>
> ![image-20230412170318569](https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230412170318569.png)



### 存储

MySQL 永久保存数据

Redis 作为缓存，提高热点数据的访问速度

> 如果缓存的数据量太大，可以用 Redis 集群

提高系统的并发，可以 读写分离 、 分库分表

> 读写分离：数据库的读和写操作分到不同的数据库节点上。主服务器负责写，从服务器负责读。可以大幅提高读性能，小幅提高写性能。