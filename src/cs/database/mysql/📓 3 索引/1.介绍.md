# 索引（index）

帮助MySQL高效**获取数据**的数据结构（有序）

> 如果不加索引，会从头到尾全部遍历（可能有多个）



### 优点

* 提高数据检索效率、降低数据库的IO成本
* 通过索引对数据排序，降低排序的成本、降低CPU的消耗

### 缺点

* 索引列占据空间
* 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；
* 降低更新表的速度（INSERT、UPDATE、DELETE）





## 索引分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。



### 数据结构分类

#### 0⃣️ 二叉树索引

缺点：顺序插入时，会形成链表，查询性能大大降低

> 红黑树可解决：自平衡

数据量大时，层级深、检索速度慢

> 二叉树的弊端



#### 0⃣️ B树（B-Tree多路平衡查找树）

以一颗最大度数为5的b树为例

【每个节点最多存储4个key，5个指针】

> 因为指针是key之间的范围，所以指针数比key多1

![image-20230103231159538](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230103231159538.png)

满员后：

中间元素向上分裂，其余分成两边





#### 1⃣️ B+ Tree索引

**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

> 最常见、大部分引擎都支持
>
> B树的变体

叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是**按主键顺序存放**的。每一层父节点的索引值都会出现在下层子节点的索引值中

所有的节点都会出现在叶子结点

叶子结点之间形成双向链表

>  与经典B+树相比，MySQL增加了相邻叶子结点之间的指针



> 数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。
>
> B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，

##### 优点：

* 比二叉树层级少，搜索效率高
* 对于B树，叶子结点和非叶子结点都会保存，导致一页中存储的键值减少、指针减少，要保存大量数据，只能增加树的高度、降低性能。B+树只在叶子结点存储数据，单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。
* B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找



#### 2⃣️ Hash索引

采用hash算法，将键值换算，映射到对应的槽位上

> 如果发生冲突，可以采用链表的方式解决

特点：

1. 只有精确匹配才有效，不支持范围查询
2. 无法用索引完成排序
3. 效率高，通常只需要一次检索（除了冲突时）

存储引擎：

Memory引擎支持hash索引，InnoDB自适应hash功能



#### 3⃣️ R-tree空间索引

MyISAM引擎的特殊索引类型，较少用（主要用于地理空间数据类型）



#### 4⃣️ Full-text全文索引

建立倒排索引，快速匹配文档





### 物理存储分类

#### 1⃣️ 聚集索引｜主键索引

**聚集索引｜主键索引**选取规则：

* **如果有主键，主键索引就是聚集索引**
* 如果没有，将会用第一个唯一索引作为聚集索引
* 如果都没有，InnoDB会自动生成一个rowid作为隐藏的聚集索引

id的索引：聚集索引——叶子结点挂的是这一行的数据

其他字段（name）：二级索引——叶子结点挂的是主键



#### 2⃣️ 二级索引｜辅助索引

- 主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。

在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是**覆盖索引。**

如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是**回表**。



### 字段特性分类

#### 主键索引

建立在主键字段上的索引，通常在创建表的时候一起创建

一张表最多只有一个主键索引

不允许有空值。

#### 唯一索引

建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引

值必须唯一

允许有空值

#### 普通索引

```sql
INDEX(index_column_1,index_column_2,...) 
```

#### 前缀索引

对**字符类型**字段的前几个字符建立的索引，而不是在整个字段上建立的索引

目的：减少索引占用的存储空间，提升查询效率。



### 字段个数分类

#### 单列索引

#### 联合索引

使用联合索引时，存在**最左匹配原则**

如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。

> 利用索引的前提是索引里的 key 是有序的

**最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。**

**对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配**



##### 索引下推

- 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。
- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， **可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**。



## 索引语法

* ##### 创建索引

  ```sql
  CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name(index_col_name,...);
  ```

  如果不加 `[]` ，说明创建的是常规索引

  `Index_col_name` 表示关联的字段

  联合索引：写多个col name

  > 联合索引的col name顺序表示建立索引的先后，即先按照第一列排序，第一列相同则按照第二列排序

* ##### 查看索引

  ```sql
  SHOW INDEX FROM table_name;
  ```

* ##### 删除索引

  ```sql
  DROP INDEX index_name ON table_name;
  ```



## 适用条件

* 字段唯一性
* 经常用于 `WHERE` 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引
* 经常用于 `GROUP BY` 和 `ORDER BY` 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的



### 不需要创建的情况

- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。

- 存在大量重复数据，不需要创建索引，比如性别字段

  > MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。

- 表数据太少的时候，不需要创建索引；

- 经常更新的字段不用创建索引

  比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，影响数据库性能。



## 优化索引

### 前缀索引优化

使用字符串的前几个字符建立索引

优点：

为了减小索引字段大小，增加一个索引页中存储的索引值，有效提高索引的查询速度

局限性：

- order by 就无法使用前缀索引；
- 无法把前缀索引用作覆盖索引；



### 覆盖索引优化

SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过主键索引查询获得，可以避免回表的操作。

优点：

不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作



### 主键索引最好自增

InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。

也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。

**非自增主键**，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**页分裂**。**页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。

出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。

而如果记录是顺序插入的，则只需开辟新的数据页，也就不会发生页分裂



### 主键字段的长度不要太大

因为**主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小**。



### 索引最好NOT NULL

- 第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如**进行索引统计**时，count 会省略值为NULL 的行。
- 第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题



### 防止索引失效

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

查看执行计划，通过执行计划显示的数据判断查询语句是否使用了索引。

key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；