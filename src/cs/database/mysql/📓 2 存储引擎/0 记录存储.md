# 记录的存储



存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件也不同。

以 InnoDB 存储引擎为例

数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件。

![image-20230322110559100](https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230322110559100.png)



## 表文件结构

### 段

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合，MVCC 利用了回滚段实现了多版本查询数据。



### 区

 InnoDB 存储引擎用 B+ 树来组织数据，每一层都是通过双向链表连接

> 如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，非常慢的。

让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 

**在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。**



### 页

数据库的读写单位

默认每个页的大小为 16KB

页的类型有很多，常见的有数据页、undo 日志页、溢出页等等，表中的记录存储在**「数据页」**里面



### 行

记录的存放单位，每行记录根据不同的行格式，有不同的存储结构。





## InnoDB行格式

Redundant、Compact、Dynamic和 Compressed 

- Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。
- Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。



### Compact行格式？

一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分

![image-20230322111810193](https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230322111810193.png)

#### 记录的额外信息

##### 变长字段长度列表

变长字段实际存储的数据的长度（大小）不固定

把数据占用的大小存起来，存到这里面，读取数据的时候才能根据这个去读取对应长度的数据。

真实数据占用的字节数会按照列的顺序**逆序存放**

> **使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。



MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列

**NULL 不会存放在行格式中记录的真实数据部分里**

变长字段长度列表不是必须的，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。



##### NULL 值列表

把这些 NULL 值都放到记录的真实数据中会浪费空间

如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序**逆序排列**。

- 二进制位的值为`1`时，代表该列的值为NULL。
- 二进制位的值为`0`时，代表该列的值不为NULL。

另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 `0`。

NULL 值列表不是必须的。

**当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**。



##### 记录头信息

- delete_mask ：执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 **delete_mask 标记为 1。**
- next_record：下一条记录的位置。记录与记录之间是通过链表组织的，指向的是下一条记录的「记录头信息」和「真实数据」**之间的位置**，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录



#### 记录的真实数据

除了定义的字段，还有三个隐藏字段，分别为：

row_id：如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。

trx_id：表示这个数据是由哪个事务生成的，是必需的

roll_pointer：记录上一个版本的指针，是必需的





### Varchar(n) n的最大取值？

**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。



存储字段类型为 varchar(n) 的数据时，其实分成了三个部分来存储：

- 真实数据
- 真实数据占用的字节数
- NULL 标识，如果不允许为NULL，这部分不需要

在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数

**如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= varchar（65535）**。





### 行溢出怎么办？

磁盘和内存交互的基本单位是页，页的大小一般是 `16KB`，也就是 `16384字节`，而一个 varchar(n) 类型的列最多可以存储 `65532字节`

在一般情况下，InnoDB 的数据都是存放在 「数据页」中

如果一个数据页存不了一个记录，会将溢出的数据存放到溢出页里

当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址

![image-20230323101644861](https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230323101644861.png)



Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于**处理行溢出数据时有区别**。

这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。