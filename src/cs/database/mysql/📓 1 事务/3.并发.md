# 并发



## 并发引发的问题

### 1⃣️ 脏读

一个事务读取到另一个未提交事务修改的数据

> 因为这个修改数据的事务还没提交，可能发生回滚。如果回滚，读取数据的事务得到的就是过期数据。



### 2⃣️ 不可重复读

一个事务内多次读取同一条记录，但是两次读取的数据不同

> 例如：一个事务查询两次，另一个事务在中间的时候update



### 3⃣️ 幻读

一个事务按照条件查询数据时，没有对应的数据行，但是插入时已经存在

多次查询某个符合查询条件的「记录数量」，出现前后两次查询到的记录数量不一样的情况。



> 例如：一个事务先查后增，另一个事务同时增





## 事务隔离级别

较高的隔离级别牺牲性能

- **读未提交（\*read uncommitted\*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读已提交（\*read committed\*）**，指一个事务提交之后，它做的变更才能被其他事务看到；
- **可重复读（\*repeatable read\*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；
- **序列化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；

> Oracle数据库的默认：Read committed

![image-20230405163827139](https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405163827139.png)



**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象**

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务**启动时看到的数据是一致的**。即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个**插入语句就会被阻塞**，无法成功插入，所以就很好了避免幻读问题。



```sql
-- 查看事务隔离级别
SELECT@@TRANSACTION_ISOLATION;

-- 设置事务隔离级别
SET[SESSION|GLOBAL]TRANSACTION ISOLATION LEVER {READ UNCOMMITTED|...}
```



### 隔离级别的实现

- 对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；

- 对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；

- 对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的**区别在于创建 Read View 的时机不同**

  「读提交」隔离级别是在「**每个语句执行前」**都会重新生成一个 Read View，

  「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。



## 在MVCC的工作？



### ReadView重要字段

四个重要字段

![image-20230405164929550](https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405164929550.png)





### 聚簇索引的两个隐藏列

- trx_id，当一个事务对某条聚簇索引记录进行改动时，就会**把该事务的事务 id 记录在 trx_id 隐藏列里**；
- roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后**这个隐藏列是个指针，指向每一个旧版本记录**，于是就可以通过它找到修改前的记录。



在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：

![image-20230405165926485](https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405165926485.png)

一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：

- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的`min_trx_id`和`max_trx_id`之间，需要判断 trx_id 是否在 m_ids 列表中：
  - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
  - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**





## MVCC

### 可重复读

**第一次快照读时生成一个 Read View，然后整个事务期间都在用这个 Read View**。

在事务期间读到的记录都是事务启动前的记录

### 读提交

**在每次快照读时，都会生成一个新的 Read View**。

在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。





对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：

- 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
- 「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。

这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。

在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。







## 可重复读不能解决幻读的情况



### 可以解决的原理

执行第一个查询语句后，会创建一个 Read View，**后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的**，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。



### 不能的情况

第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为**当事务 A 更新了一条事务 B 插入的记录**，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。

第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而**是先快照读**，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。



要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。
