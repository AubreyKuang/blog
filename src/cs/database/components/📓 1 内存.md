# 内存

宏观层面：c语言、操作系统、计算机组成中，内存知识串讲



## 1⃣️计算机组成：内存条、总线、DMA

###两块芯片：

cpu芯片、南桥芯片

内存条，cpu在主办上通过总线交互；南桥接USB、网卡、声卡

###读取文件：

CPU——DMAC（控制器）——把磁盘内容读到内存中（直接访问内存）——DMAC反馈给CPU

节省cpu这一计算资源，把总线控制权也交给DMAC

#####两者不能同时使用总线



## 2⃣️【OS】操作系统：内存管理与分类



Mem是内存，Swap是磁盘交换分区

### 【1】为什么要有逻辑地址：

程序无法知道可用的物理地址，故必须映射。

除非是单线程的机器。

###【2】逻辑地址如何与物理地址映射：

###1.固定偏移量映射

缺陷：部分内存无法利用，内碎片；若内存被释放，影响后续程序，外碎片

###2.分页

程序逻辑内存分为多个页，物理内存分为多个帧

从页到帧的映射需要页表【存储：数字对应、是否可用、读写权限等】

![image-20230109213747950](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230109213747950.png)

磁盘换进了物理内存，不太常用的帧逐出到磁盘 故linux下这个磁盘部分叫swapping

如果对应的帧号是磁盘，则用页面置换算法，选出要逐出的页帧

![image-20230109213800851](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230109213800851.png)

###【3】分页中的时间与空间优化

##### 1.时间优化：

将最常用的页表存到访问速度更快的硬件中（一般在MMU内存管理单元中，这个小表名为TLB[快表]）

先寻址——查TLB——miss——查PT

因为程序最常访问的页没几个，所以快表命中率很高

##### 2.空间优化：

使用多极页表

###【4】程序内部的内存管理——分段

堆、栈：

现在说的段，常不是原本内存管理的段，而是逻辑意义的段

text 二进制 data 变量

malloc若申请>128k的内存会调用mmap，在堆和栈之间区域申请内存。

是页映射磁盘（mmap是文件映射内存的系统调用）

共享内存很常见，如windows下选择文件的对话框

![截屏2021-07-27 下午9.13.43](/Users/apple/Library/Application%2520Support/typora-user-images/%25E6%2588%25AA%25E5%25B1%258F2021-07-27%2520%25E4%25B8%258B%25E5%258D%25889.13.43.png)

### 【5】CPU缓存cache如何起作用



## 3⃣️内存相关的系统调用

用户态切内核态的方式之一，申请内存需要用到系统调用。

（用户无法之间操控硬件，交给内核操作完了再把结果返回）

C语言：

###【1】sbrk库函数

````c
int main(){
	void *first = sbrk(o); /* *是赋值 */
	printf("%p\n,first")
}


$./a.out  /*返回路径*/
0x1dab000
  
  
  
  
 #include <sutdio.h>
 #include <unistd.h>
  int main(){
  	int *first = (int *)sbrk(1); /*把指针变为int类型*/
    *(first +1) = 123; /*int+1 四个字节+1 第五个字节。*赋值，第5678字节*/
  	printf("%d\n",*(first +1));
}


$./a.out
 123
````

堆空间中连续的内存

第一个为1，直接令5678位为123，不会报错，是因为sbrk申请的是1页（6字节），故赋值内容可以支配



### 【2】mmap函数

#####内核空间和用户空间在页表的映射相同，有时也称共享空间（不是组线那样的共享），无需内核空间中转，直接由用户空间映射，省去了内核空间到用户空间的拷贝。

>  零拷贝技术还有很多，mmap不是最好的，如java-nio等技术

#####但是没法利用对文件缓存的空间。而且缺页异常和root函数耗时未必哪个更短。



128kb以下，对应的释放内存函数为munmap

内存使用是惰性的，如果不每个赋值，则操作系统不会给。故每一页都用for循环赋值。

~~~c
#include <stdio.h>
#include < unistd.h>
#inclde <sys/mman.h>
int main(){
  int*a = (int *)mmap(NULL, 100*4096,PROT_READ|PROT_WRITE,MAP_PRIVATE|MAP_ANOYMOUS,-1,0);
  int *b=a;
  for(int i=0,i<100;i++){
    b=(void *)a+(i*4096);
    *b=1;
  }
  while (1){
    sleep(1);
  }
}
~~~

mmap还有直接将文件映射到内存的作用，也能读文件

只调用一次，直到真正读文件时才映射

~~~~c
for(int i =0,i<sb.st_size; i++){
	printf("%c",file_in_memory[i]);
}
~~~~

这一页发现在磁盘中，触发缺页错误（大错误）majflt

大错误后，文件全部加载到了物理内存，后面小错误是要把虚拟内存对应到物理内存上



## 4⃣️JAVA中的内存

堆、栈、本地方法栈、程序计数器、方法区、metaspace、指针压缩

栈（jvm栈）：存当前运行方法的一些局部变量，创建对象一般在栈

​		基础对象类型，数据引用

本地方法栈：c++

#### 对象：

头（Mark Word 【8字节】，Klass Word【四字节，指针指向metaspace】，Array Lengh） +对象内容

Klass中java_mirror指针指向Class对象



java中的对象是8字节对齐的，所以可以用32bit的地址表示2^ ^2*8Byte=32GB的内存地址

所以在堆内存32G以内都是默认开启指针压缩的，每个对象的地址都用4个字节表示。但堆超过32G则无法压缩，每个对象地址必须用8字节表示。

![image-20230109213620452](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230109213620452.png)