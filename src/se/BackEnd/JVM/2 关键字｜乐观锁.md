# 关键字



## volatile

* 保证变量的可见性，如果我们将变量声明为 **`volatile`** ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

* **防止 JVM 的指令重排序。** 如果我们将变量声明为 **`volatile`** ，在对这个变量进行读写操作的时候，会通过插入特定的 **内存屏障** 的方式来禁止指令重排序。



### 不原子性

#### 自增操作

自增操作 inc ++ 不是原子性的：

1. 读取 inc 的值。
2. 对 inc 加 1。
3. 将 inc 的值写回内存。

`volatile` 是无法保证这三个操作是具有原子性，可能导致：

线程 1 对 `inc` 进行读取操作之后，还未对其进行修改。线程 2 又读取了 `inc`的值并对其进行修改（+1），再将`inc` 的值写回内存。

线程 2 操作完毕后，线程 1 对 `inc`的值进行修改（+1），再将`inc` 的值写回内存。

两个线程分别对 `inc` 进行了一次自增操作后，`inc` 实际上只增加了 1。

改进：

`synchronized` 、`Lock`或者`AtomicInteger`都可以。

![image-20230426165157420](https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230426165157420.png)





### 双重校验锁实现单例模式

```java
public class Singleton {
  
  private volatile static Singleton uniqueInstance;
  
  private Singleton() {
    
  }
  
  public static Singleton getUniqueInstance() {
    // 判断对象是否实例化，没有实例化后才进入加锁代码
    if (uniqueInstance == null) {
      // 类对象加锁
      synchronized (Singleton.class) {
        if (uniqueInstance == null) {
          uniqueInstance = new Singleton();
        }
      }
    }
    return uniqueInstance;
  }
}
```

` uniqueInstance = new Singleton():`

1. 为 `uniqueInstance` 分配内存空间
2. 初始化 `uniqueInstance`
3. 将 `uniqueInstance` 指向分配的内存地址

由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。

指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程**获得还没有初始化的实例**。

例如，线程 T1 执行了 1 和 3，此时 T2 调用 `getUniqueInstance`() 后发现 `uniqueInstance` 不为空，因此返回 `uniqueInstance`，但此时 `uniqueInstance` 还未被初始化。





> 在JDK1.8中，`java.lang.Runtime`类使用了双重校验锁实现的单例模式。以下是该类的示例代码：
>
> ```shell
> class Runtime {
>     private static volatile Runtime currentRuntime;
>     public static Runtime getRuntime() {
>         if (currentRuntime == null) {
>             synchronized (Runtime.class) {
>                 if (currentRuntime == null) {
>                     currentRuntime = new Runtime();
>                 }
>             }
>         }
>         return currentRuntime;
>     }
>     // other methods...
> }
> ```
>
> 在上面的代码中，`currentRuntime`是一个`volatile`类型的静态变量，它确保了多线程环境下的可见性。`getRuntime()`方法首先检查`currentRuntime`是否为`null`，如果是，则进入同步块。在同步块中，再次检查`currentRuntime`是否为`null`，如果是，则创建一个新的`Runtime`对象并赋值给`currentRuntime`。最后，返回`currentRuntime`对象。这种方式可以保证在多线程环境下只创建一个`Runtime`对象。





## 乐观锁悲观锁

### 悲观锁

认为共享资源每次被访问的时候就会出现问题(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。

也就是说，**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**。

像 Java 中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

高并发的场景下，激烈的锁竞争会造成线程阻塞，大量**阻塞线程会导致系统的上下文切换，增加系统的性能开销**。并且，悲观锁还可能会存在死锁问题，影响代码的正常运行。



### 乐观锁

认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在**提交修改的时候去验证**对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。



高并发的场景下，乐观锁相比悲观锁来说，不存在锁竞争造成线程阻塞，也不会有死锁的问题，在性能上往往会更胜一筹。

但是，如果**冲突频繁发生**（写占比非常多的情况），会**频繁失败和重试**，这样同样会非常影响性能，导致 CPU 飙升。

不过，大量失败重试的问题也是可以解决的，借助 `LongAdder`以空间换时间的方式就解决了这个问题。



- 悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如`LongAdder`），也是可以考虑使用乐观锁的，要视实际情况而定。
- 乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是**单个共享变量**（参考`java.util.concurrent.atomic`包下面的原子变量类）。



#### 乐观锁的实现

##### 版本号机制

在数据表中加上一个数据版本号 `version` 字段，表示数据被修改的次数。当数据被修改时，`version` 值会加一。

当线程 A 要更新数据值时，在**读取数据的同时也会读取 `version` 值**，在**提交更新**时，若**刚才读取**到的 version 值为**当前**数据库中的 `version` 值相等时才更新，否则重试更新操作，直到更新成功。



##### CAS 算法

**Compare And Swap（比较与交换）** ，用于实现乐观锁，被广泛应用于各大框架中。就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。

CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。

> **原子操作** 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。

CAS 涉及到三个操作数：

- **V** ：要更新的变量值(Var)
- **E** ：预期值(Expected)
- **N** ：拟写入的新值(New)

当且仅当 V 的值等于 E 时，CAS 通过原子方式用新值 N 来更新 V 的值。**如果不等，说明已经有其它线程更新了** V，则当前线程放弃更新。



#### 乐观锁的问题

1. **ABA 问题**

   初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，不能说明没有被其他线程修改过了。在这段时间它的值可能被改为其他值，然后又改回 A，那 CAS 操作就会误认为它从来没有被修改过。

   解决思路是在变量前面追加上**版本号或者时间戳**。

   > JDK 1.5 以后的 `AtomicStampedReference` 类就是用来解决 ABA 问题的，其中的 `compareAndSet()` 方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。



2. **循环时间长开销大**

   CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。

   > 如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用：
   >
   > 1. 可以延迟流水线执行指令，使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。
   > 2. 可以避免在退出循环的时候因内存顺序冲而引起 CPU 流水线被清空，从而提高 CPU 的执行效率。

   

3. **只能保证一个共享变量的原子操作**

   只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。

   > 但是从 JDK 1.5 开始，提供了`AtomicReference`类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作.所以我们可以使用锁或者利用`AtomicReference`类把多个共享变量合并成一个共享变量来操作。



## synchronized

解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

在 Java 早期版本中，`synchronized` 属于 **重量级锁**，效率低下。这是因为监视器锁（monitor）**是依赖于底层的操作系统的 `Mutex Lock` 来实现的**，Java 的线程是映射到操作系统的原生线程之上的。如果要**挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态**，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。

不过，在 Java 6 之后， `synchronized` **引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销**，这些优化让 `synchronized` 锁的效率提升了很多。因此， `synchronized` 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 `synchronized` 。



### 使用方式

1. 修饰实例方法

   给对象实例上锁；

> 以下两种都是对类上锁

2. 修饰静态方法

> 静态 `synchronized` 方法和非静态 `synchronized` 方法之间的调用不互斥：
>
> 因为访问静态 `synchronized` 方法占用的锁是当前类的锁，而访问非静态 `synchronized` 方法占用的锁是当前实例对象锁。

3. 修饰代码块

对括号里指定的对象/类加锁：



* 尽量不要使用 `synchronized(String a)` 因为 JVM 中，字符串常量池具有缓存功能。



### 可以修饰构造方法吗？

**不能使用 synchronized 关键字修饰。**

构造方法本身就属于线程安全的，不存在同步的构造方法一说。



### 底层原理？