import{_ as e,V as t,W as n,X as a,Y as s}from"./framework-91a010c2.js";const l={},c=a("h1",{id:"算法总结",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#算法总结","aria-hidden":"true"},"#"),s(" 算法总结")],-1),o=a("h2",{id:"滑动窗口",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#滑动窗口","aria-hidden":"true"},"#"),s(" 滑动窗口")],-1),r=a("p",null,[s("解决一类连续区间问题。它可以在"),a("span",{class:"katex"},[a("span",{class:"katex-mathml"},[a("math",{xmlns:"http://www.w3.org/1998/Math/MathML"},[a("semantics",null,[a("mrow",null,[a("mi",null,"O"),a("mo",{stretchy:"false"},"("),a("mi",null,"n"),a("mo",{stretchy:"false"},")")]),a("annotation",{encoding:"application/x-tex"},"O(n)")])])]),a("span",{class:"katex-html","aria-hidden":"true"},[a("span",{class:"base"},[a("span",{class:"strut",style:{height:"1em","vertical-align":"-0.25em"}}),a("span",{class:"mord mathnormal",style:{"margin-right":"0.02778em"}},"O"),a("span",{class:"mopen"},"("),a("span",{class:"mord mathnormal"},"n"),a("span",{class:"mclose"},")")])])]),s("的时间复杂度内解决很多需要遍历连续区间的问题，相比暴力枚举，具有更高的效率。")],-1),h=a("p",null,"滑动窗口算法的基本思想是维护一个区间，在满足一定条件的前提下，尽可能地向右滑动这个区间。在每次滑动的过程中，都要更新区间内部的信息，并且根据需求更新问题的答案。当滑动到右边界不能继续向右移动时，算法结束。",-1),i=a("p",null,"滑动窗口算法的实现通常采用两个指针来维护区间，即一个左指针和一个右指针。初始时，两个指针都指向区间的左边界。然后，我们让右指针不断向右移动，直到区间不满足某些条件为止。在这个过程中，我们要不断更新区间内部的信息，并根据问题需求更新问题的答案。当右指针不能再向右移动时，我们让左指针向右移动一位，并重复上述过程。在每一轮滑动窗口时，我们都需要判断当前区间是否满足问题所要求的条件。",-1),m=[c,o,r,h,i];function _(d,p){return t(),n("div",null,m)}const x=e(l,[["render",_],["__file","算法总结.html.vue"]]);export{x as default};
