import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as o,o as n}from"./app-fVbzsCFO.js";const r={};function p(l,e){return n(),t("div",null,e[0]||(e[0]=[o('<h1 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h1><h2 id="基本数据类型" tabindex="-1"><a class="header-anchor" href="#基本数据类型"><span>基本数据类型</span></a></h2><p><img src="https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230424110028070.png" alt="image-20230424110028070"></p><blockquote><p>java 中使用 long 类型的数据一定要在数值后面加 L，否则将作为整型解析</p></blockquote><p>对应的包装类型：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p><h3 id="与包装类型的区别" tabindex="-1"><a class="header-anchor" href="#与包装类型的区别"><span>与包装类型的区别</span></a></h3><ol><li>包装类型不赋值为 null，基本类型有默认值</li><li>jvm 层面，基本数据类型直接放在 java 虚拟机栈的局部变量表中（占用更小空间），包装类型属于对象类型，对象类型实例存在堆中</li></ol><h4 id="包装类型的常量池技术" tabindex="-1"><a class="header-anchor" href="#包装类型的常量池技术"><span>包装类型的常量池技术</span></a></h4><p>Byte, Short, Integer, Long 默认创建了数值 [-128, 127] 的相应类型的缓存数据，Character 创建数值在 [0, 127] 的相应范围的缓存数据，Boolean 返回 true/false</p><p>当代码中出现这些数值时，会直接使用缓存中的对象。如果在这个区域外，都会在堆上产生，所以建议用 <code>equals</code>方法判断</p><p>两种浮点数类型的包装类 Float, Double 没有实现常量池技术</p><blockquote><p>答案为 False</p><p><img src="https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230424111057085.png" alt="image-20230424111057085"></p></blockquote><h4 id="包装类型的意义" tabindex="-1"><a class="header-anchor" href="#包装类型的意义"><span>包装类型的意义？</span></a></h4><p>Java中的包装类型是为了将基本数据类型转换为对象而设计的。这些包装类型提供了一些额外的功能，例如可以将基本数据类型转换为对象，可以在集合中存储基本数据类型，可以使用null值表示缺少值等等。</p><p>此外，包装类型还提供了一些有用的方法，例如将字符串转换为基本数据类型，将基本数据类型转换为字符串等等。</p><p>在实际编程中，我们通常使用基本数据类型来表示简单的数据，但是在某些情况下，我们需要将基本数据类型转换为对象，这时就需要使用包装类型。</p><h3 id="自动拆装箱" tabindex="-1"><a class="header-anchor" href="#自动拆装箱"><span>自动拆装箱</span></a></h3><p>基本数据类型和包装类型的转换</p><p>装箱：调用包装类的 valueOf()</p><p>拆箱：xxxValue() 方法</p><p><strong>频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><h4 id="自动拆箱引发的-npe-问题" tabindex="-1"><a class="header-anchor" href="#自动拆箱引发的-npe-问题"><span>自动拆箱引发的 NPE 问题</span></a></h4><p>自动拆箱是将包装类型转换为其对应的基本类型的过程。当一个包装类型的值为 <code>null</code> 时，自动拆箱会引发 <code>NullPointerException</code>。</p><p>这是因为基本类型不能为 <code>null</code>，所以在自动拆箱时，编译器会尝试访问一个 <code>null</code> 值的属性或方法，从而导致异常的抛出。为了避免这种情况，可以在自动拆箱之前检查包装类型是否为 <code>null</code>。</p>',24)]))}const s=a(r,[["render",p]]),g=JSON.parse(`{"path":"/se/BackEnd/%F0%9F%8C%9F%20java%E9%9B%86%E5%90%88/1%20%E5%9F%BA%E7%A1%80/0%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html","title":"数据类型","lang":"en-US","frontmatter":{"description":"数据类型 基本数据类型 image-20230424110028070 java 中使用 long 类型的数据一定要在数值后面加 L，否则将作为整型解析 对应的包装类型：Byte, Short, Integer, Long, Float, Double, Character, Boolean 与包装类型的区别 包装类型不赋值为 null，基本类型有默认...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数据类型\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230424110028070.png\\",\\"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230424111057085.png\\"],\\"dateModified\\":\\"2025-08-18T03:49:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aubrey\\",\\"url\\":\\"https://github.com/aubreykuang\\"}]}"],["meta",{"property":"og:url","content":"https://aubreykuang.github.io/blog/blog/se/BackEnd/%F0%9F%8C%9F%20java%E9%9B%86%E5%90%88/1%20%E5%9F%BA%E7%A1%80/0%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"Aubrey's Blog"}],["meta",{"property":"og:title","content":"数据类型"}],["meta",{"property":"og:description","content":"数据类型 基本数据类型 image-20230424110028070 java 中使用 long 类型的数据一定要在数值后面加 L，否则将作为整型解析 对应的包装类型：Byte, Short, Integer, Long, Float, Double, Character, Boolean 与包装类型的区别 包装类型不赋值为 null，基本类型有默认..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230424110028070.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-08-18T03:49:31.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-18T03:49:31.000Z"}]]},"git":{"createdTime":1682502198000,"updatedTime":1755488971000,"contributors":[{"name":"KoryKL","username":"KoryKL","email":"1274994508@qq.com","commits":1,"url":"https://github.com/KoryKL"},{"name":"kory","username":"kory","email":"apple@kuangyongbeideMacBook-Air.local","commits":1,"url":"https://github.com/kory"}]},"readingTime":{"minutes":2.22,"words":666},"filePathRelative":"se/BackEnd/🌟 java集合/1 基础/0 数据类型.md","excerpt":"\\n<h2>基本数据类型</h2>\\n<p><img src=\\"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230424110028070.png\\" alt=\\"image-20230424110028070\\"></p>\\n<blockquote>\\n<p>java 中使用 long 类型的数据一定要在数值后面加 L，否则将作为整型解析</p>\\n</blockquote>\\n<p>对应的包装类型：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p>","autoDesc":true}`);export{s as comp,g as data};
