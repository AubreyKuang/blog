import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as e,o as n}from"./app-0rC9aSp6.js";const t={};function p(h,a){return n(),s("div",null,a[0]||(a[0]=[e(`<h1 id="sql优化" tabindex="-1"><a class="header-anchor" href="#sql优化"><span>SQL优化</span></a></h1><blockquote><p>和索引的优化关系很大</p></blockquote><h3 id="_1⃣️-插入数据" tabindex="-1"><a class="header-anchor" href="#_1⃣️-插入数据"><span>1⃣️ 插入数据</span></a></h3><h4 id="insert优化" tabindex="-1"><a class="header-anchor" href="#insert优化"><span>insert优化</span></a></h4><h5 id="_1-批量插入" tabindex="-1"><a class="header-anchor" href="#_1-批量插入"><span>1. 批量插入</span></a></h5><p><code>insert into tb_test values(1, &#39;Tom&#39;),(2, &#39;Cat&#39;),(3, &#39;Jerry&#39;);</code></p><h5 id="_2-手动提交事务" tabindex="-1"><a class="header-anchor" href="#_2-手动提交事务"><span>2. 手动提交事务</span></a></h5><p>避免频发提交事务</p><p><code>start transaction;</code></p><p><code>...</code></p><p><code>commit;</code></p><h5 id="_3-主键顺序插入" tabindex="-1"><a class="header-anchor" href="#_3-主键顺序插入"><span>3. 主键顺序插入</span></a></h5><p>比乱序插入效率更高</p><h4 id="大批量插入数据" tabindex="-1"><a class="header-anchor" href="#大批量插入数据"><span>大批量插入数据</span></a></h4><p>不用 <code>insert</code> 而用 <code>load</code></p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 客户端连接服务器时，加上参数 --local-infile</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">mysql </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">--local-infile -u root -p</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 设置全局参数locat_infile = 1，开启从本地加载文件导入数据的开关</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">set</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> global</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> locat_infile </span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> 1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 执行load指令将准备好的数据，加载到表结构中</span></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 原来的数据 ， 分割，加之后 \\n 分割</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">load</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> data</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> local</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> infile </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&#39;/root/sql1.log&#39;</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> into</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> table</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;tb_user&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> fields terminated </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">by</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;,&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> lines terminated </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">by</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> &#39;\\n&#39;</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2⃣️-主键优化" tabindex="-1"><a class="header-anchor" href="#_2⃣️-主键优化"><span>2⃣️ 主键优化</span></a></h3><h4 id="数据组织方式" tabindex="-1"><a class="header-anchor" href="#数据组织方式"><span>数据组织方式</span></a></h4><p>在InnoDB存储引擎中，表数据根据主键顺序组织存储，这种表称为索引组织表 IOT</p><h5 id="页分裂" tabindex="-1"><a class="header-anchor" href="#页分裂"><span>页分裂</span></a></h5><p>主键乱序插入</p><h5 id="页合并" tabindex="-1"><a class="header-anchor" href="#页合并"><span>页合并</span></a></h5><p>删除数据时，不会真的被删除，而是被flagged为删除、空间允许其他记录声明</p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%，在创建表或索引的时候指定），InnoDB就会寻找前后页看是否可以优化空间使用</p><h4 id="主键设计原则" tabindex="-1"><a class="header-anchor" href="#主键设计原则"><span>主键设计原则</span></a></h4><ul><li>尽量降低主键长度，因为可能有较多二级索引</li><li>插入数据时尽量顺序插入，使用AUTO_INCREMENT自增主键</li><li>尽量不要使用UUID或者其他自然主键，如身份证（乱序）</li><li>业务操作中，避免修改主键</li></ul><h3 id="_3⃣️-order-by优化" tabindex="-1"><a class="header-anchor" href="#_3⃣️-order-by优化"><span>3⃣️ order by优化</span></a></h3><p>尽量要用Using index，而不是Using filesort（所有不是通过索引直接返回排序结果的排序，需要在排序缓冲区中排序）</p><p><code>create index idx_user_age__pho_ad on tb_user(age asc, phone desc);</code></p><p>age从小到大、phone从大到小：collation列A/D</p><p>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230106170817577.png" alt="image-20230106170817577"></p><h3 id="_4⃣️-group-by优化" tabindex="-1"><a class="header-anchor" href="#_4⃣️-group-by优化"><span>4⃣️ group by优化</span></a></h3><p>多字段分组，也需要满足最左前缀法则</p><h3 id="_5⃣️-limit优化" tabindex="-1"><a class="header-anchor" href="#_5⃣️-limit优化"><span>5⃣️ limit优化</span></a></h3><p>分页操作，越往后查询效率越低</p><p>限制展示的数据数量</p><p><code>select xxx form tb_Xxx limit 100,10;</code></p><p>意思是从第100条开始查10条</p><p>优化：创建覆盖索引、子查询</p><h3 id="_6⃣️-count优化" tabindex="-1"><a class="header-anchor" href="#_6⃣️-count优化"><span>6⃣️ count优化</span></a></h3><p>MyISAM引擎将表的总行数存储在磁盘上，执行count(*)直接返回这个数，效率很高</p><p>InnoDB只能一行一行读出来、再计数</p><p>优化：自己计数</p><h5 id="count-函数" tabindex="-1"><a class="header-anchor" href="#count-函数"><span>count()函数</span></a></h5><p>不计 null</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230106173417077.png" alt="image-20230106173417077"></p><p>效率</p><p><strong>Count(*) 约等于 count(1) &gt; count(主键) &gt; count(字段)</strong></p><p>尽量用count(*)，因为数据库专门做了优化</p><h3 id="_7⃣️-update优化" tabindex="-1"><a class="header-anchor" href="#_7⃣️-update优化"><span>7⃣️ update优化</span></a></h3><p>InnoDB的行锁是针对索引加的锁，而不是针对记录加的锁，并且该索引不能失效，否则升级为表锁，降低并发性能</p>`,52)]))}const o=i(t,[["render",p]]),c=JSON.parse(`{"path":"/cs/database/mysql/%F0%9F%93%93%204%20SQL%E4%BC%98%E5%8C%96/1.html","title":"SQL优化","lang":"en-US","frontmatter":{"description":"SQL优化 和索引的优化关系很大 1⃣️ 插入数据 insert优化 1. 批量插入 insert into tb_test values(1, 'Tom'),(2, 'Cat'),(3, 'Jerry'); 2. 手动提交事务 避免频发提交事务 start transaction; ... commit; 3. 主键顺序插入 比乱序插入效率更高 大批...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"SQL优化\\",\\"image\\":[\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230106170817577.png\\",\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230106173417077.png\\"],\\"dateModified\\":\\"2023-01-07T04:59:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aubrey\\",\\"url\\":\\"https://github.com/aubreykuang\\"}]}"],["meta",{"property":"og:url","content":"https://aubreykuang.github.io/blog/blog/cs/database/mysql/%F0%9F%93%93%204%20SQL%E4%BC%98%E5%8C%96/1.html"}],["meta",{"property":"og:site_name","content":"Aubrey's Blog"}],["meta",{"property":"og:title","content":"SQL优化"}],["meta",{"property":"og:description","content":"SQL优化 和索引的优化关系很大 1⃣️ 插入数据 insert优化 1. 批量插入 insert into tb_test values(1, 'Tom'),(2, 'Cat'),(3, 'Jerry'); 2. 手动提交事务 避免频发提交事务 start transaction; ... commit; 3. 主键顺序插入 比乱序插入效率更高 大批..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230106170817577.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-01-07T04:59:04.000Z"}],["meta",{"property":"article:modified_time","content":"2023-01-07T04:59:04.000Z"}]]},"git":{"createdTime":1673067544000,"updatedTime":1673067544000,"contributors":[{"name":"KoryKL","username":"KoryKL","email":"1274994508@qq.com","commits":1,"url":"https://github.com/KoryKL"}]},"readingTime":{"minutes":2.39,"words":716},"filePathRelative":"cs/database/mysql/📓 4 SQL优化/1.md","excerpt":"\\n<blockquote>\\n<p>和索引的优化关系很大</p>\\n</blockquote>\\n<h3>1⃣️ 插入数据</h3>\\n<h4>insert优化</h4>\\n<h5>1. 批量插入</h5>\\n<p><code>insert into tb_test values(1, 'Tom'),(2, 'Cat'),(3, 'Jerry');</code></p>\\n<h5>2. 手动提交事务</h5>\\n<p>避免频发提交事务</p>\\n<p><code>start transaction;</code></p>\\n<p><code>...</code></p>\\n<p><code>commit;</code></p>","autoDesc":true}`);export{o as comp,c as data};
