import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a,o as r}from"./app-0rC9aSp6.js";const t={};function p(i,e){return r(),n("div",null,e[0]||(e[0]=[a('<h1 id="spring-ioc" tabindex="-1"><a class="header-anchor" href="#spring-ioc"><span>Spring IoC</span></a></h1><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将<strong>原本在程序中手动创建对象</strong>的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><ul><li><strong>传统的开发方式</strong> ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li><li><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。</li></ul><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。</p><p>当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><h2 id="依赖注入" tabindex="-1"><a class="header-anchor" href="#依赖注入"><span>依赖注入</span></a></h2><p>IoC 最常见以及最合理的实现方式叫做依赖注入（Dependency Injection，简称 DI）。</p><h2 id="创建-bean-容器" tabindex="-1"><a class="header-anchor" href="#创建-bean-容器"><span>创建 Bean 容器</span></a></h2><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p><h3 id="单例-bean-的线程安全问题了解吗" tabindex="-1"><a class="header-anchor" href="#单例-bean-的线程安全问题了解吗"><span>单例 Bean 的线程安全问题了解吗？</span></a></h3><p>大部分时候我们并没有在项目中使用多线程，所以很少有人会关注这个问题。单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li>在 Bean 中尽量避免定义可变的成员变量。</li><li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p><h3 id="bean-生命周期" tabindex="-1"><a class="header-anchor" href="#bean-生命周期"><span>Bean 生命周期</span></a></h3><p>Bean 容器找到配置文件中 Spring Bean 的定义。</p><p>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</p><p>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</p><p>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</p><p>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</p><p>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</p><p>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</p><p>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</p><p>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</p><p>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</p><p>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</p><p>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</p><p>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p><h2 id="aop" tabindex="-1"><a class="header-anchor" href="#aop"><span>AOP</span></a></h2><p>Aspect-Oriented Programming:面向切面编程，是 OOP（面向对象编程）的一种延续。</p><p>横向抽取机制，将横切逻辑代码和业务逻辑代码分离</p><p>有利于未来的可拓展性和可维护性。</p><p>基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p><p><img src="https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230412115742554.png" alt="image-20230412115742554"></p>',37)]))}const g=o(t,[["render",p]]),d=JSON.parse(`{"path":"/se/BackEnd/SpringBoot/2%20Spring%20IoC%20%EF%BD%9C%20AOP.html","title":"Spring IoC","lang":"en-US","frontmatter":{"description":"Spring IoC IoC（Inversion of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。 传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Spring IoC\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230412115742554.png\\"],\\"dateModified\\":\\"2025-08-18T03:49:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aubrey\\",\\"url\\":\\"https://github.com/aubreykuang\\"}]}"],["meta",{"property":"og:url","content":"https://aubreykuang.github.io/blog/blog/se/BackEnd/SpringBoot/2%20Spring%20IoC%20%EF%BD%9C%20AOP.html"}],["meta",{"property":"og:site_name","content":"Aubrey's Blog"}],["meta",{"property":"og:title","content":"Spring IoC"}],["meta",{"property":"og:description","content":"Spring IoC IoC（Inversion of Control:控制反转） 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。 传统的开发方式 ：往往是在类 A 中手动通过 new 关键字来 new 一个..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230412115742554.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-08-18T03:49:31.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-18T03:49:31.000Z"}]]},"git":{"createdTime":1682502198000,"updatedTime":1755488971000,"contributors":[{"name":"KoryKL","username":"KoryKL","email":"1274994508@qq.com","commits":1,"url":"https://github.com/KoryKL"},{"name":"kory","username":"kory","email":"apple@kuangyongbeideMacBook-Air.local","commits":1,"url":"https://github.com/kory"}]},"readingTime":{"minutes":3.52,"words":1057},"filePathRelative":"se/BackEnd/SpringBoot/2 Spring IoC ｜ AOP.md","excerpt":"\\n<p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将<strong>原本在程序中手动创建对象</strong>的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p>\\n<ul>\\n<li><strong>传统的开发方式</strong> ：往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li>\\n<li><strong>使用 IoC 思想的开发方式</strong> ：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面过去即可。</li>\\n</ul>","autoDesc":true}`);export{g as comp,d as data};
