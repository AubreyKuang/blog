import{_ as a,V as e,W as r,a0 as i}from"./framework-91a010c2.js";const d={},t=i('<h1 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist" aria-hidden="true">#</a> ArrayList</h1><p>无参构造，长度为0的数组</p><p>加了数字，使用制定容量的</p><p>如果传入集合，长度为集合大小</p><h2 id="扩容" tabindex="-1"><a class="header-anchor" href="#扩容" aria-hidden="true">#</a> 扩容</h2><h3 id="add自动扩容" tabindex="-1"><a class="header-anchor" href="#add自动扩容" aria-hidden="true">#</a> Add自动扩容</h3><p>&gt;&gt; 1找到一半 + 原来的长度</p><h3 id="addall方法" tabindex="-1"><a class="header-anchor" href="#addall方法" aria-hidden="true">#</a> addAll方法</h3><p>在自动扩容、增加的长度之间选择较大值</p><h2 id="迭代器" tabindex="-1"><a class="header-anchor" href="#迭代器" aria-hidden="true">#</a> 迭代器</h2><h3 id="failfast-failsafe" tabindex="-1"><a class="header-anchor" href="#failfast-failsafe" aria-hidden="true">#</a> failfast｜failsafe</h3><p>fail-fast：一旦发现遍历同时其他修改，抛出异常</p><blockquote><p>ArrayList的模式⬆️</p></blockquote><p>源码：记录了循环前后集合的<strong>修改次数</strong>，比较是否一致</p><p>fail-safe：发现时应对，为了完成遍历，例如牺牲一致性（遍历读取的数据不是最新）</p><p>源码：add方法复制原来的数组，长度+1，最新元素加到后面；读写分离</p><h2 id="和linkedlist比较" tabindex="-1"><a class="header-anchor" href="#和linkedlist比较" aria-hidden="true">#</a> 和LinkedList比较</h2><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230202183605834.png" alt="image-20230202183605834" loading="lazy"></p><p>因为Node存储本身数据，还有上下指针</p><h3 id="arraylist-1" tabindex="-1"><a class="header-anchor" href="#arraylist-1" aria-hidden="true">#</a> Arraylist</h3><p>继承 RandomAccess 随机访问</p><p>随机访问快</p><h2 id="cpu读写" tabindex="-1"><a class="header-anchor" href="#cpu读写" aria-hidden="true">#</a> CPU读写</h2><p>内存读写一次效率低，所以设置CPU缓存</p><p>数组：相邻数据也会读入CPU缓存区</p><p>链表：不会，因为存储空间可能不相邻</p>',26),h=[t];function s(n,l){return e(),r("div",null,h)}const p=a(d,[["render",s],["__file","1 ArrayList.html.vue"]]);export{p as default};
