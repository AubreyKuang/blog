import{_ as e,V as a,W as n,a0 as s}from"./framework-91a010c2.js";const r={},i=s(`<h1 id="并发" tabindex="-1"><a class="header-anchor" href="#并发" aria-hidden="true">#</a> 并发</h1><h2 id="并发引发的问题" tabindex="-1"><a class="header-anchor" href="#并发引发的问题" aria-hidden="true">#</a> 并发引发的问题</h2><h3 id="_1⃣️-脏读" tabindex="-1"><a class="header-anchor" href="#_1⃣️-脏读" aria-hidden="true">#</a> 1⃣️ 脏读</h3><p>一个事务读取到另一个未提交事务修改的数据</p><blockquote><p>因为这个修改数据的事务还没提交，可能发生回滚。如果回滚，读取数据的事务得到的就是过期数据。</p></blockquote><h3 id="_2⃣️-不可重复读" tabindex="-1"><a class="header-anchor" href="#_2⃣️-不可重复读" aria-hidden="true">#</a> 2⃣️ 不可重复读</h3><p>一个事务内多次读取同一条记录，但是两次读取的数据不同</p><blockquote><p>例如：一个事务查询两次，另一个事务在中间的时候update</p></blockquote><h3 id="_3⃣️-幻读" tabindex="-1"><a class="header-anchor" href="#_3⃣️-幻读" aria-hidden="true">#</a> 3⃣️ 幻读</h3><p>一个事务按照条件查询数据时，没有对应的数据行，但是插入时已经存在</p><p>多次查询某个符合查询条件的「记录数量」，出现前后两次查询到的记录数量不一样的情况。</p><blockquote><p>例如：一个事务先查后增，另一个事务同时增</p></blockquote><h2 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别" aria-hidden="true">#</a> 事务隔离级别</h2><p>较高的隔离级别牺牲性能</p><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读已提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>序列化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><blockquote><p>Oracle数据库的默认：Read committed</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230405163827139.png" alt="image-20230405163827139" loading="lazy"></p><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</strong></p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务<strong>启动时看到的数据是一致的</strong>。即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个<strong>插入语句就会被阻塞</strong>，无法成功插入，所以就很好了避免幻读问题。</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 查看事务隔离级别</span>
<span class="token keyword">SELECT</span>@<span class="token variable">@TRANSACTION_ISOLATION</span><span class="token punctuation">;</span>

<span class="token comment">-- 设置事务隔离级别</span>
<span class="token keyword">SET</span><span class="token punctuation">[</span><span class="token keyword">SESSION</span><span class="token operator">|</span><span class="token keyword">GLOBAL</span><span class="token punctuation">]</span><span class="token keyword">TRANSACTION</span> <span class="token keyword">ISOLATION</span> LEVER {<span class="token keyword">READ</span> <span class="token keyword">UNCOMMITTED</span><span class="token operator">|</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="隔离级别的实现" tabindex="-1"><a class="header-anchor" href="#隔离级别的实现" aria-hidden="true">#</a> 隔离级别的实现</h3><ul><li><p>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</p></li><li><p>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</p></li><li><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的<strong>区别在于创建 Read View 的时机不同</strong></p><p>「读提交」隔离级别是在「**每个语句执行前」**都会重新生成一个 Read View，</p><p>「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</p></li></ul><h2 id="在mvcc的工作" tabindex="-1"><a class="header-anchor" href="#在mvcc的工作" aria-hidden="true">#</a> 在MVCC的工作？</h2><h3 id="readview重要字段" tabindex="-1"><a class="header-anchor" href="#readview重要字段" aria-hidden="true">#</a> ReadView重要字段</h3><p>四个重要字段</p><p><img src="https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230405164929550.png" alt="image-20230405164929550" loading="lazy"></p><h3 id="聚簇索引的两个隐藏列" tabindex="-1"><a class="header-anchor" href="#聚簇索引的两个隐藏列" aria-hidden="true">#</a> 聚簇索引的两个隐藏列</h3><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p><p><img src="https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230405165926485.png" alt="image-20230405165926485" loading="lazy"></p><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在 m_ids 列表中： <ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p><h2 id="mvcc" tabindex="-1"><a class="header-anchor" href="#mvcc" aria-hidden="true">#</a> MVCC</h2><h3 id="可重复读" tabindex="-1"><a class="header-anchor" href="#可重复读" aria-hidden="true">#</a> 可重复读</h3><p><strong>第一次快照读时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p>在事务期间读到的记录都是事务启动前的记录</p><h3 id="读提交" tabindex="-1"><a class="header-anchor" href="#读提交" aria-hidden="true">#</a> 读提交</h3><p><strong>在每次快照读时，都会生成一个新的 Read View</strong>。</p><p>在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p><h2 id="可重复读不能解决幻读的情况" tabindex="-1"><a class="header-anchor" href="#可重复读不能解决幻读的情况" aria-hidden="true">#</a> 可重复读不能解决幻读的情况</h2><h3 id="可以解决的原理" tabindex="-1"><a class="header-anchor" href="#可以解决的原理" aria-hidden="true">#</a> 可以解决的原理</h3><p>执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p><h3 id="不能的情况" tabindex="-1"><a class="header-anchor" href="#不能的情况" aria-hidden="true">#</a> 不能的情况</h3><p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为<strong>当事务 A 更新了一条事务 B 插入的记录</strong>，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p><p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而<strong>是先快照读</strong>，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>`,51),t=[i];function d(o,l){return a(),n("div",null,t)}const p=e(r,[["render",d],["__file","3.并发.html.vue"]]);export{p as default};
