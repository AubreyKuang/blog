import{_ as a,V as i,W as e,a0 as h}from"./framework-91a010c2.js";const p={},c=h('<h1 id="线程" tabindex="-1"><a class="header-anchor" href="#线程" aria-hidden="true">#</a> 线程</h1><h2 id="java中的线程状态" tabindex="-1"><a class="header-anchor" href="#java中的线程状态" aria-hidden="true">#</a> java中的线程状态</h2><h3 id="六种" tabindex="-1"><a class="header-anchor" href="#六种" aria-hidden="true">#</a> 六种</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230205162545895.png" alt="image-20230205162545895" loading="lazy"></p><h3 id="五种" tabindex="-1"><a class="header-anchor" href="#五种" aria-hidden="true">#</a> 五种</h3><p>操作系统的划分方法</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230212160540093.png" alt="image-20230212160540093" loading="lazy"></p><p>新建</p><p>就绪：可以分到cpu时间</p><p>运行：分到cpu时间</p><p>阻塞：分不到cpu时间</p><p>终结</p><p>java中的runnable涵盖了就绪、运行、阻塞IO</p><h2 id="线程池的核心参数🌟" tabindex="-1"><a class="header-anchor" href="#线程池的核心参数🌟" aria-hidden="true">#</a> 线程池的核心参数🌟</h2><p>任务执行完后要保留？核心线程：救急线程</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230212161917922.png" alt="image-20230212161917922" loading="lazy"></p><h3 id="拒绝策略" tabindex="-1"><a class="header-anchor" href="#拒绝策略" aria-hidden="true">#</a> 拒绝策略</h3><p>AbortPolicy</p><p>所有线程耗尽，新任务不能执行</p><p>CallerRunsPolicy</p><p>谁调用，谁执行</p><p>DiscardOldestPolicy</p><p>丢弃等待最久的任务</p><h3 id="sleep-wait方法对比" tabindex="-1"><a class="header-anchor" href="#sleep-wait方法对比" aria-hidden="true">#</a> sleep wait方法对比</h3><p>共同：效果都是让当前线程放弃CPU使用权，进入堵塞</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230212183913901.png" alt="image-20230212183913901" loading="lazy"></p><p><code>wait()</code>方法必须配合LOCK一起用</p><p>需要获得LOCK之后再调用</p><h3 id="lock-和-synchronized-对比" tabindex="-1"><a class="header-anchor" href="#lock-和-synchronized-对比" aria-hidden="true">#</a> lock 和 synchronized 对比</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230212194339949.png" alt="image-20230212194339949" loading="lazy"></p><h4 id="lock锁的特性" tabindex="-1"><a class="header-anchor" href="#lock锁的特性" aria-hidden="true">#</a> lock锁的特性</h4><p>阻塞</p><p>公平锁与非公平锁</p><h5 id="条件变量" tabindex="-1"><a class="header-anchor" href="#条件变量" aria-hidden="true">#</a> 条件变量</h5><p>condition</p><h3 id="volatile能否保证线程安全" tabindex="-1"><a class="header-anchor" href="#volatile能否保证线程安全" aria-hidden="true">#</a> volatile能否保证线程安全</h3><p>是三个方面：可见性、有序性、原子性</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230212214327695.png" alt="image-20230212214327695" loading="lazy"></p><p>可见✅</p><p>有序✅</p><p>原子</p><blockquote><p>eg：加减运算</p><ol><li>原始值</li><li>getstatic</li><li>inconstant_变化值</li><li>iadd</li><li>putstatic</li></ol></blockquote><p>一条代码的底层可能对应多条指令</p><p>多线程下指令的交错（可以用锁解决）</p>',44),n=[c];function t(d,l){return i(),e("div",null,n)}const o=a(p,[["render",t],["__file","1 线程.html.vue"]]);export{o as default};
