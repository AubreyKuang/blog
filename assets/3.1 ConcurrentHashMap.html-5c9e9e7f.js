const e=JSON.parse(`{"key":"v-22308f76","path":"/se/BackEnd/%F0%9F%8C%9F%20java%E9%9B%86%E5%90%88/1%20%E5%9F%BA%E7%A1%80/3.1%20ConcurrentHashMap.html","title":"","lang":"en-US","frontmatter":{"description":"Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。 Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。","head":[["meta",{"property":"og:url","content":"https://korykl.github.io/blog/blog/se/BackEnd/%F0%9F%8C%9F%20java%E9%9B%86%E5%90%88/1%20%E5%9F%BA%E7%A1%80/3.1%20ConcurrentHashMap.html"}],["meta",{"property":"og:site_name","content":"Kory's Blog"}],["meta",{"property":"og:description","content":"Java7 中 ConcurrentHashMap 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 Segment 都是一个类似 HashMap 数组的结构，它可以扩容，它的冲突会转化为链表。但是 Segment 的个数一但初始化就不能改变。 Java8 中的 ConcurrentHashMap 使用的 Synchronized 锁加 CAS 的机制。结构也由 Java7 中的 Segment 数组 + HashEntry 数组 + 链表 进化成了 Node 数组 + 链表 / 红黑树，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-04-06T03:21:04.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-04-06T03:21:04.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://korykl.github.io/blog/blog/zh/se/BackEnd/%F0%9F%8C%9F%20java%E9%9B%86%E5%90%88/1%20%E5%9F%BA%E7%A1%80/3.1%20ConcurrentHashMap.html"}]]},"headers":[],"git":{"createdTime":1680751264000,"updatedTime":1680751264000,"contributors":[{"name":"KoryKL","email":"1274994508@qq.com","commits":1}]},"readingTime":{"minutes":0.54,"words":162},"localizedDate":"April 6, 2023","filePathRelative":"se/BackEnd/🌟 java集合/1 基础/3.1 ConcurrentHashMap.md","excerpt":"<p>Java7 中 <code>ConcurrentHashMap</code> 使用的分段锁，也就是每一个 Segment 上同时只有一个线程可以操作，每一个 <code>Segment</code> 都是一个类似 <code>HashMap</code> 数组的结构，它可以扩容，它的冲突会转化为链表。但是 <code>Segment</code> 的个数一但初始化就不能改变。</p>\\n<p>Java8 中的 <code>ConcurrentHashMap</code> 使用的 <code>Synchronized</code> 锁加 CAS 的机制。结构也由 Java7 中的 <strong><code>Segment</code> 数组 + <code>HashEntry</code> 数组 + 链表</strong> 进化成了 <strong>Node 数组 + 链表 / 红黑树</strong>，Node 是类似于一个 HashEntry 的结构。它的冲突再达到一定大小时会转化成红黑树，在冲突小于一定数量时又退回链表。</p>","autoDesc":true}`);export{e as data};
