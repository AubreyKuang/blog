import{_ as r,V as n,W as i,a0 as o}from"./framework-91a010c2.js";const a={},e=o('<h1 id="spring-基础" tabindex="-1"><a class="header-anchor" href="#spring-基础" aria-hidden="true">#</a> Spring 基础</h1><p>轻量级 Java 开发框架，是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）</p><h2 id="模块" tabindex="-1"><a class="header-anchor" href="#模块" aria-hidden="true">#</a> 模块</h2><h3 id="core-container" tabindex="-1"><a class="header-anchor" href="#core-container" aria-hidden="true">#</a> Core Container</h3><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。</p><ul><li><strong>spring-core</strong> ：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong> ：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong> ：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong> ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h3 id="aop" tabindex="-1"><a class="header-anchor" href="#aop" aria-hidden="true">#</a> AOP</h3><ul><li><strong>spring-aspects</strong> ：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong> ：提供了面向切面的编程实现。</li></ul><h3 id="data-access-integration" tabindex="-1"><a class="header-anchor" href="#data-access-integration" aria-hidden="true">#</a> Data Access/Integration</h3><ul><li><strong>spring-jdbc</strong> ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li><strong>spring-tx</strong> ：提供对事务的支持。</li><li><strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li><li><strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h2 id="spring-spring-mvc-spring-boot-的关系" tabindex="-1"><a class="header-anchor" href="#spring-spring-mvc-spring-boot-的关系" aria-hidden="true">#</a> Spring, Spring MVC, Spring Boot 的关系</h2><p>Spring 轻量级 Java 开发框架，是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用</p><h3 id="spring-boot" tabindex="-1"><a class="header-anchor" href="#spring-boot" aria-hidden="true">#</a> Spring Boot</h3><h4 id="启动流程" tabindex="-1"><a class="header-anchor" href="#启动流程" aria-hidden="true">#</a> 启动流程</h4><p>Spring Boot项目创建完成会默认生成一个名为 *Application 的入口类，通过该类的main方法启动Spring Boot项目的。在main方法中，通过SpringApplication的静态方法，即run方法进行SpringApplication类的实例化操作，然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。</p><p>其中，SpringApplication在run方法中重点做了以下操作：</p><ul><li>获取监听器和参数配置；</li><li>打印Banner信息；</li><li>创建并初始化容器；</li><li>监听器发送通知。</li></ul><h4 id="自动装配" tabindex="-1"><a class="header-anchor" href="#自动装配" aria-hidden="true">#</a> 自动装配</h4><p>引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。</p><p>Spring Boot通过@EnableAutoConfiguration注解开启自动配置</p><p><img src="https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230413213112326.png" alt="image-20230413213112326" loading="lazy"></p><h4 id="注解" tabindex="-1"><a class="header-anchor" href="#注解" aria-hidden="true">#</a> 注解</h4><p>@SpringBootApplication注解：</p><p>在Spring Boot入口类中，唯一的一个注解就是@SpringBootApplication。它是Spring Boot项目的核心注解，用于开启自动配置，准确说是通过该注解内组合的@EnableAutoConfiguration开启了自动配置。</p><p>@EnableAutoConfiguration注解：</p><p>@EnableAutoConfiguration的主要功能是启动Spring应用程序上下文时进行自动配置，它会尝试猜测并配置项目可能需要的Bean。自动配置通常是基于项目classpath中引入的类和已定义的Bean来实现的。在此过程中，被自动配置的组件来自项目自身和项目依赖的jar包中。</p><p>@Import注解：</p><p>@EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分，也是自动配置功能的核心实现者。</p><p>@Conditional注解：</p><p>@Conditional注解是由Spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行Bean的实例化及装配，比如，设定当类路径下包含某个jar包的时候才会对注解的类进行实例化操作。总之，就是根据一些特定条件来控制Bean实例化的行为。</p><p>@Conditional衍生注解：</p><p>在Spring Boot的autoconfigure项目中提供了各类基于@Conditional注解的衍生注解，它们适用不同的场景并提供了不同的功能。通过阅读这些注解的源码，你会发现它们其实都组合了@Conditional注解，不同之处是它们在注解中指定的条件（Condition）不同。</p><h2 id="spring-ioc" tabindex="-1"><a class="header-anchor" href="#spring-ioc" aria-hidden="true">#</a> Spring IoC</h2><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将<strong>原本在程序中手动创建对象</strong>的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。这大大增加了项目的可维护性且降低了开发难度。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><h2 id="spring-mvc" tabindex="-1"><a class="header-anchor" href="#spring-mvc" aria-hidden="true">#</a> Spring MVC</h2><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>可以帮助我们进行更简洁的 Web 层的开发，并且与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><h3 id="核心组件" tabindex="-1"><a class="header-anchor" href="#核心组件" aria-hidden="true">#</a> 核心组件</h3><ul><li><strong><code>DispatcherServlet</code></strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code></strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code></strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code></strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code></strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul>',45),t=[e];function p(s,g){return n(),i("div",null,t)}const d=r(a,[["render",p],["__file","1 基础.html.vue"]]);export{d as default};
