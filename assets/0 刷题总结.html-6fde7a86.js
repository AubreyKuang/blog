const e=JSON.parse(`{"key":"v-711ce4fc","path":"/algo/%F0%9F%93%93%20%E6%80%BB%E7%BB%93/%F0%9F%93%92%20%E4%BA%8C%E5%8F%89%E6%A0%91/0%20%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.html","title":"刷题总结","lang":"en-US","frontmatter":{"description":"刷题总结 层序遍历 Problem: 剑指 Offer 32 - I. 从上到下打印二叉树 打印结果不用存储层次信息，所以只用一层List /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int[] levelOrder(TreeNode root) { // List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); List&lt;Integer&gt; results = new ArrayList&lt;&gt;(); if (root == null) { return new int[0]; } Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); // int levelIndex = 0; while (!queue.isEmpty()) { // List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) { TreeNode node = queue.poll(); results.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } // results.add(level); // levelIndex++; } int[] answer = new int[results.size()]; for (int i = 0 ; i &lt; results.size(); i++) { answer[i] = results.get(i); } return answer; } }","head":[["meta",{"property":"og:url","content":"https://korykl.github.io/blog/blog/algo/%F0%9F%93%93%20%E6%80%BB%E7%BB%93/%F0%9F%93%92%20%E4%BA%8C%E5%8F%89%E6%A0%91/0%20%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.html"}],["meta",{"property":"og:site_name","content":"Kory's Blog"}],["meta",{"property":"og:title","content":"刷题总结"}],["meta",{"property":"og:description","content":"刷题总结 层序遍历 Problem: 剑指 Offer 32 - I. 从上到下打印二叉树 打印结果不用存储层次信息，所以只用一层List /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int[] levelOrder(TreeNode root) { // List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;(); List&lt;Integer&gt; results = new ArrayList&lt;&gt;(); if (root == null) { return new int[0]; } Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;(); queue.offer(root); // int levelIndex = 0; while (!queue.isEmpty()) { // List&lt;Integer&gt; level = new ArrayList&lt;&gt;(); int size = queue.size(); for (int i = 0; i &lt; size; i++) { TreeNode node = queue.poll(); results.add(node.val); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } } // results.add(level); // levelIndex++; } int[] answer = new int[results.size()]; for (int i = 0 ; i &lt; results.size(); i++) { answer[i] = results.get(i); } return answer; } }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-03-02T11:03:58.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-03-02T11:03:58.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://korykl.github.io/blog/blog/zh/algo/%F0%9F%93%93%20%E6%80%BB%E7%BB%93/%F0%9F%93%92%20%E4%BA%8C%E5%8F%89%E6%A0%91/0%20%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.html"}]]},"headers":[{"level":2,"title":"层序遍历","slug":"层序遍历","link":"#层序遍历","children":[]}],"git":{"createdTime":1677754801000,"updatedTime":1677755038000,"contributors":[{"name":"KoryKL","email":"1274994508@qq.com","commits":2}]},"readingTime":{"minutes":0.5,"words":151},"localizedDate":"March 2, 2023","filePathRelative":"algo/📓 总结/📒 二叉树/0 刷题总结.md","excerpt":"<h1> 刷题总结</h1>\\n<h2> 层序遍历</h2>\\n<blockquote>\\n<p>Problem: 剑指 Offer 32 - I. 从上到下打印二叉树</p>\\n</blockquote>\\n<p>打印结果不用存储层次信息，所以只用一层List</p>\\n<div class=\\"language-Java line-numbers-mode\\" data-ext=\\"Java\\"><pre class=\\"language-Java\\"><code>\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public int[] levelOrder(TreeNode root) {\\n\\n        // List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;&gt;();\\n        List&lt;Integer&gt; results = new ArrayList&lt;&gt;();\\n\\n        if (root == null) {\\n            return new int[0];\\n        }\\n\\n        Queue&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();\\n        queue.offer(root);\\n        // int levelIndex = 0;\\n\\n        while (!queue.isEmpty()) {\\n            // List&lt;Integer&gt; level = new ArrayList&lt;&gt;();\\n            int size = queue.size();\\n            for (int i = 0; i &lt; size; i++) {\\n                TreeNode node = queue.poll();\\n                results.add(node.val);\\n                if (node.left != null) {\\n                    queue.offer(node.left);\\n                }\\n                if (node.right != null) {\\n                    queue.offer(node.right);\\n                }\\n            }\\n            // results.add(level);\\n            // levelIndex++;\\n\\n        }\\n\\n        int[] answer = new int[results.size()];\\n        for (int i = 0 ; i &lt; results.size(); i++) {\\n            answer[i] = results.get(i);\\n        }\\n        return answer;\\n    }\\n}\\n</code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}`);export{e as data};
