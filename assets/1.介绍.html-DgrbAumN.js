import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as i,o as n}from"./app-0rC9aSp6.js";const l={};function h(t,a){return n(),s("div",null,a[0]||(a[0]=[i('<h1 id="索引-index" tabindex="-1"><a class="header-anchor" href="#索引-index"><span>索引（index）</span></a></h1><p>帮助MySQL高效<strong>获取数据</strong>的数据结构（有序）</p><blockquote><p>如果不加索引，会从头到尾全部遍历（可能有多个）</p></blockquote><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点"><span>优点</span></a></h3><ul><li>提高数据检索效率、降低数据库的IO成本</li><li>通过索引对数据排序，降低排序的成本、降低CPU的消耗</li></ul><h3 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点"><span>缺点</span></a></h3><ul><li>索引列占据空间</li><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li><li>降低更新表的速度（INSERT、UPDATE、DELETE）</li></ul><h2 id="索引分类" tabindex="-1"><a class="header-anchor" href="#索引分类"><span>索引分类</span></a></h2><ul><li>按「数据结构」分类：<strong>B+tree索引、Hash索引、Full-text索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><h3 id="数据结构分类" tabindex="-1"><a class="header-anchor" href="#数据结构分类"><span>数据结构分类</span></a></h3><h4 id="_0⃣️-二叉树索引" tabindex="-1"><a class="header-anchor" href="#_0⃣️-二叉树索引"><span>0⃣️ 二叉树索引</span></a></h4><p>缺点：顺序插入时，会形成链表，查询性能大大降低</p><blockquote><p>红黑树可解决：自平衡</p></blockquote><p>数据量大时，层级深、检索速度慢</p><blockquote><p>二叉树的弊端</p></blockquote><h4 id="_0⃣️-b树-b-tree多路平衡查找树" tabindex="-1"><a class="header-anchor" href="#_0⃣️-b树-b-tree多路平衡查找树"><span>0⃣️ B树（B-Tree多路平衡查找树）</span></a></h4><p>以一颗最大度数为5的b树为例</p><p>【每个节点最多存储4个key，5个指针】</p><blockquote><p>因为指针是key之间的范围，所以指针数比key多1</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230103231159538.png" alt="image-20230103231159538"></p><p>满员后：</p><p>中间元素向上分裂，其余分成两边</p><h4 id="_1⃣️-b-tree索引" tabindex="-1"><a class="header-anchor" href="#_1⃣️-b-tree索引"><span>1⃣️ B+ Tree索引</span></a></h4><p><strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><blockquote><p>最常见、大部分引擎都支持</p><p>B树的变体</p></blockquote><p>叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是<strong>按主键顺序存放</strong>的。每一层父节点的索引值都会出现在下层子节点的索引值中</p><p>所有的节点都会出现在叶子结点</p><p>叶子结点之间形成双向链表</p><blockquote><p>与经典B+树相比，MySQL增加了相邻叶子结点之间的指针</p></blockquote><blockquote><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，</p></blockquote><h5 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1"><span>优点：</span></a></h5><ul><li>比二叉树层级少，搜索效率高</li><li>对于B树，叶子结点和非叶子结点都会保存，导致一页中存储的键值减少、指针减少，要保存大量数据，只能增加树的高度、降低性能。B+树只在叶子结点存储数据，单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</li><li>B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找</li></ul><h4 id="_2⃣️-hash索引" tabindex="-1"><a class="header-anchor" href="#_2⃣️-hash索引"><span>2⃣️ Hash索引</span></a></h4><p>采用hash算法，将键值换算，映射到对应的槽位上</p><blockquote><p>如果发生冲突，可以采用链表的方式解决</p></blockquote><p>特点：</p><ol><li>只有精确匹配才有效，不支持范围查询</li><li>无法用索引完成排序</li><li>效率高，通常只需要一次检索（除了冲突时）</li></ol><p>存储引擎：</p><p>Memory引擎支持hash索引，InnoDB自适应hash功能</p><h4 id="_3⃣️-r-tree空间索引" tabindex="-1"><a class="header-anchor" href="#_3⃣️-r-tree空间索引"><span>3⃣️ R-tree空间索引</span></a></h4><p>MyISAM引擎的特殊索引类型，较少用（主要用于地理空间数据类型）</p><h4 id="_4⃣️-full-text全文索引" tabindex="-1"><a class="header-anchor" href="#_4⃣️-full-text全文索引"><span>4⃣️ Full-text全文索引</span></a></h4><p>建立倒排索引，快速匹配文档</p><h3 id="物理存储分类" tabindex="-1"><a class="header-anchor" href="#物理存储分类"><span>物理存储分类</span></a></h3><h4 id="_1⃣️-聚集索引-主键索引" tabindex="-1"><a class="header-anchor" href="#_1⃣️-聚集索引-主键索引"><span>1⃣️ 聚集索引｜主键索引</span></a></h4><p><strong>聚集索引｜主键索引</strong>选取规则：</p><ul><li><strong>如果有主键，主键索引就是聚集索引</strong></li><li>如果没有，将会用第一个唯一索引作为聚集索引</li><li>如果都没有，InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ul><p>id的索引：聚集索引——叶子结点挂的是这一行的数据</p><p>其他字段（name）：二级索引——叶子结点挂的是主键</p><h4 id="_2⃣️-二级索引-辅助索引" tabindex="-1"><a class="header-anchor" href="#_2⃣️-二级索引-辅助索引"><span>2⃣️ 二级索引｜辅助索引</span></a></h4><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引。</strong></p><p>如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p><h3 id="字段特性分类" tabindex="-1"><a class="header-anchor" href="#字段特性分类"><span>字段特性分类</span></a></h3><h4 id="主键索引" tabindex="-1"><a class="header-anchor" href="#主键索引"><span>主键索引</span></a></h4><p>建立在主键字段上的索引，通常在创建表的时候一起创建</p><p>一张表最多只有一个主键索引</p><p>不允许有空值。</p><h4 id="唯一索引" tabindex="-1"><a class="header-anchor" href="#唯一索引"><span>唯一索引</span></a></h4><p>建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引</p><p>值必须唯一</p><p>允许有空值</p><h4 id="普通索引" tabindex="-1"><a class="header-anchor" href="#普通索引"><span>普通索引</span></a></h4><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(index_column_1,index_column_2,...)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h4 id="前缀索引" tabindex="-1"><a class="header-anchor" href="#前缀索引"><span>前缀索引</span></a></h4><p>对<strong>字符类型</strong>字段的前几个字符建立的索引，而不是在整个字段上建立的索引</p><p>目的：减少索引占用的存储空间，提升查询效率。</p><h3 id="字段个数分类" tabindex="-1"><a class="header-anchor" href="#字段个数分类"><span>字段个数分类</span></a></h3><h4 id="单列索引" tabindex="-1"><a class="header-anchor" href="#单列索引"><span>单列索引</span></a></h4><h4 id="联合索引" tabindex="-1"><a class="header-anchor" href="#联合索引"><span>联合索引</span></a></h4><p>使用联合索引时，存在<strong>最左匹配原则</strong></p><p>如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><blockquote><p>利用索引的前提是索引里的 key 是有序的</p></blockquote><p><strong>最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。</strong></p><p><strong>对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p><h5 id="索引下推" tabindex="-1"><a class="header-anchor" href="#索引下推"><span>索引下推</span></a></h5><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul><h2 id="索引语法" tabindex="-1"><a class="header-anchor" href="#索引语法"><span>索引语法</span></a></h2><ul><li><h5 id="创建索引" tabindex="-1"><a class="header-anchor" href="#创建索引"><span>创建索引</span></a></h5><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">CREATE</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;"> [UNIQUE|FULLTEXT]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ON</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name(index_col_name,...);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>如果不加 <code>[]</code> ，说明创建的是常规索引</p><p><code>Index_col_name</code> 表示关联的字段</p><p>联合索引：写多个col name</p><blockquote><p>联合索引的col name顺序表示建立索引的先后，即先按照第一列排序，第一列相同则按照第二列排序</p></blockquote></li><li><h5 id="查看索引" tabindex="-1"><a class="header-anchor" href="#查看索引"><span>查看索引</span></a></h5><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">SHOW </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">INDEX</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> FROM</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li><li><h5 id="删除索引" tabindex="-1"><a class="header-anchor" href="#删除索引"><span>删除索引</span></a></h5><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">DROP</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> INDEX</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> index_name </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ON</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> table_name;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div></li></ul><h2 id="适用条件" tabindex="-1"><a class="header-anchor" href="#适用条件"><span>适用条件</span></a></h2><ul><li>字段唯一性</li><li>经常用于 <code>WHERE</code> 查询条件的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引</li><li>经常用于 <code>GROUP BY</code> 和 <code>ORDER BY</code> 的字段，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道了建立索引之后在 B+Tree 中的记录都是排序好的</li></ul><h3 id="不需要创建的情况" tabindex="-1"><a class="header-anchor" href="#不需要创建的情况"><span>不需要创建的情况</span></a></h3><ul><li><p><code>WHERE</code> 条件，<code>GROUP BY</code>，<code>ORDER BY</code> 里用不到的字段，索引的价值是快速定位，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。</p></li><li><p>存在大量重复数据，不需要创建索引，比如性别字段</p><blockquote><p>MySQL 还有一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比很高的时候，它一般会忽略索引，进行全表扫描。</p></blockquote></li><li><p>表数据太少的时候，不需要创建索引；</p></li><li><p>经常更新的字段不用创建索引</p><p>比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于要维护 B+Tree的有序性，那么就需要频繁的重建索引，影响数据库性能。</p></li></ul><h2 id="优化索引" tabindex="-1"><a class="header-anchor" href="#优化索引"><span>优化索引</span></a></h2><h3 id="前缀索引优化" tabindex="-1"><a class="header-anchor" href="#前缀索引优化"><span>前缀索引优化</span></a></h3><p>使用字符串的前几个字符建立索引</p><p>优点：</p><p>为了减小索引字段大小，增加一个索引页中存储的索引值，有效提高索引的查询速度</p><p>局限性：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h3 id="覆盖索引优化" tabindex="-1"><a class="header-anchor" href="#覆盖索引优化"><span>覆盖索引优化</span></a></h3><p>SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过主键索引查询获得，可以避免回表的操作。</p><p>优点：</p><p>不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作</p><h3 id="主键索引最好自增" tabindex="-1"><a class="header-anchor" href="#主键索引最好自增"><span>主键索引最好自增</span></a></h3><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。</p><p>也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p><strong>非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>出现页分裂时，需要将一个页的记录移动到另外一个页，性能会受到影响，同时页空间的利用率下降，造成存储空间的浪费。</p><p>而如果记录是顺序插入的，则只需开辟新的数据页，也就不会发生页分裂</p><h3 id="主键字段的长度不要太大" tabindex="-1"><a class="header-anchor" href="#主键字段的长度不要太大"><span>主键字段的长度不要太大</span></a></h3><p>因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong>。</p><h3 id="索引最好not-null" tabindex="-1"><a class="header-anchor" href="#索引最好not-null"><span>索引最好NOT NULL</span></a></h3><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如<strong>进行索引统计</strong>时，count 会省略值为NULL 的行。</li><li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题</li></ul><h3 id="防止索引失效" tabindex="-1"><a class="header-anchor" href="#防止索引失效"><span>防止索引失效</span></a></h3><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><p>查看执行计划，通过执行计划显示的数据判断查询语句是否使用了索引。</p><p>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</p>',108)]))}const o=e(l,[["render",h]]),d=JSON.parse(`{"path":"/cs/database/mysql/%F0%9F%93%93%203%20%E7%B4%A2%E5%BC%95/1.%E4%BB%8B%E7%BB%8D.html","title":"索引（index）","lang":"en-US","frontmatter":{"description":"索引（index） 帮助MySQL高效获取数据的数据结构（有序） 如果不加索引，会从头到尾全部遍历（可能有多个） 优点 提高数据检索效率、降低数据库的IO成本 通过索引对数据排序，降低排序的成本、降低CPU的消耗 缺点 索引列占据空间 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大； 降低更新表的速度（INSERT、UPDATE、DELE...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"索引（index）\\",\\"image\\":[\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230103231159538.png\\"],\\"dateModified\\":\\"2023-04-06T03:21:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aubrey\\",\\"url\\":\\"https://github.com/aubreykuang\\"}]}"],["meta",{"property":"og:url","content":"https://aubreykuang.github.io/blog/blog/cs/database/mysql/%F0%9F%93%93%203%20%E7%B4%A2%E5%BC%95/1.%E4%BB%8B%E7%BB%8D.html"}],["meta",{"property":"og:site_name","content":"Aubrey's Blog"}],["meta",{"property":"og:title","content":"索引（index）"}],["meta",{"property":"og:description","content":"索引（index） 帮助MySQL高效获取数据的数据结构（有序） 如果不加索引，会从头到尾全部遍历（可能有多个） 优点 提高数据检索效率、降低数据库的IO成本 通过索引对数据排序，降低排序的成本、降低CPU的消耗 缺点 索引列占据空间 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大； 降低更新表的速度（INSERT、UPDATE、DELE..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230103231159538.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-04-06T03:21:04.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-06T03:21:04.000Z"}]]},"git":{"createdTime":1672758980000,"updatedTime":1680751264000,"contributors":[{"name":"KoryKL","username":"KoryKL","email":"1274994508@qq.com","commits":6,"url":"https://github.com/KoryKL"}]},"readingTime":{"minutes":10.11,"words":3033},"filePathRelative":"cs/database/mysql/📓 3 索引/1.介绍.md","excerpt":"\\n<p>帮助MySQL高效<strong>获取数据</strong>的数据结构（有序）</p>\\n<blockquote>\\n<p>如果不加索引，会从头到尾全部遍历（可能有多个）</p>\\n</blockquote>\\n<h3>优点</h3>\\n<ul>\\n<li>提高数据检索效率、降低数据库的IO成本</li>\\n<li>通过索引对数据排序，降低排序的成本、降低CPU的消耗</li>\\n</ul>\\n<h3>缺点</h3>\\n<ul>\\n<li>索引列占据空间</li>\\n<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增大；</li>\\n<li>降低更新表的速度（INSERT、UPDATE、DELETE）</li>\\n</ul>","autoDesc":true}`);export{o as comp,d as data};
