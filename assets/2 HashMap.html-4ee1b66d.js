import{_ as a,V as e,W as h,a0 as i}from"./framework-91a010c2.js";const n={},t=i('<h1 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h1><h2 id="高频面试题" tabindex="-1"><a class="header-anchor" href="#高频面试题" aria-hidden="true">#</a> 高频面试题</h2><h3 id="_1⃣️-底层数据结构" tabindex="-1"><a class="header-anchor" href="#_1⃣️-底层数据结构" aria-hidden="true">#</a> 1⃣️ 底层数据结构？</h3><p>1.7 数组 + 链表</p><p><strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p><p><strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p>1.8 数组 + 链表 ｜ 红黑树 （根据数据量多少而转换）</p><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><h3 id="_2⃣️-为什么红黑树-为什么一上来不树化-要转化-为什么阈值是8-什么时候树化-什么时候退化成链表" tabindex="-1"><a class="header-anchor" href="#_2⃣️-为什么红黑树-为什么一上来不树化-要转化-为什么阈值是8-什么时候树化-什么时候退化成链表" aria-hidden="true">#</a> 2⃣️ 为什么红黑树？为什么一上来不树化，要转化？为什么阈值是8？什么时候树化，什么时候退化成链表？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203153742311.png" alt="image-20230203153742311" loading="lazy"></p><p>退化的判定：移除之前</p><p>链表太长影响查询性能</p><p>因为容量较小时，树化性能没有优势</p><p>红黑树底层是TreeNode，内存占用更多</p><h4 id="快速查找" tabindex="-1"><a class="header-anchor" href="#快速查找" aria-hidden="true">#</a> 快速查找</h4><p>计算哈希码 - 少量比较</p><h4 id="树化条件" tabindex="-1"><a class="header-anchor" href="#树化条件" aria-hidden="true">#</a> 树化条件</h4><ol><li><p>链表长度 &gt; 8</p><blockquote><p>但是链表长度可能超过8，因为如果总容量不够64，就不会树化</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203134950662.png" alt="image-20230203134950662" loading="lazy"></p></li><li><p>树容量 &gt; 64</p></li></ol><h3 id="_3⃣️-索引计算方法-有hashcode-为什么要提供hash-方法-数组容量为什么是2的n次幂" tabindex="-1"><a class="header-anchor" href="#_3⃣️-索引计算方法-有hashcode-为什么要提供hash-方法-数组容量为什么是2的n次幂" aria-hidden="true">#</a> 3⃣️ 索引计算方法？有hashcode，为什么要提供hash()方法？数组容量为什么是2的n次幂？</h3><p>容量 -1取模</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203154657869.png" alt="image-20230203154657869" loading="lazy"></p><p>数组容量2的n次幂：虽然<strong>计算效率</strong>高，但是结果的分布性不好</p><blockquote><p>如全是偶数的极端情况</p></blockquote><p>数组容量选质数，哈希分布性更好</p><p><code>int[] sizes = {23};</code></p><h3 id="_4⃣️-put方法流程-1-7-1-8版本的差异" tabindex="-1"><a class="header-anchor" href="#_4⃣️-put方法流程-1-7-1-8版本的差异" aria-hidden="true">#</a> 4⃣️ put方法流程，1.7，1.8版本的差异？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203160902816.png" alt="image-20230203160902816" loading="lazy"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203161137459.png" alt="image-20230203161137459" loading="lazy"></p><h3 id="_5⃣️-加载因子-扩容因子-为什么默认是0-75f" tabindex="-1"><a class="header-anchor" href="#_5⃣️-加载因子-扩容因子-为什么默认是0-75f" aria-hidden="true">#</a> 5⃣️ 加载因子 / 扩容因子 为什么默认是0.75f？</h3><p>控制数组存放数据的疏密程度</p><p>loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。</strong></p><h3 id="_6⃣️-多线程可能出现的问题" tabindex="-1"><a class="header-anchor" href="#_6⃣️-多线程可能出现的问题" aria-hidden="true">#</a> 6⃣️ 多线程可能出现的问题？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203162157335.png" alt="image-20230203162157335" loading="lazy"></p><h3 id="_7⃣️-put方法" tabindex="-1"><a class="header-anchor" href="#_7⃣️-put方法" aria-hidden="true">#</a> 7⃣️ put方法</h3><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><h3 id="_8⃣️-string对象的hashcode-如何设计-为什么每次乘31" tabindex="-1"><a class="header-anchor" href="#_8⃣️-string对象的hashcode-如何设计-为什么每次乘31" aria-hidden="true">#</a> 8⃣️ String对象的hashCode()如何设计？为什么每次乘31？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203174721597.png" alt="image-20230203174721597" loading="lazy"></p><p>并且31可以转化为移位加减法</p>',39),r=[t];function d(s,p){return e(),h("div",null,r)}const c=a(n,[["render",d],["__file","2 HashMap.html.vue"]]);export{c as default};
