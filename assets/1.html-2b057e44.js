import{_ as a,V as e,W as n,a1 as s}from"./framework-a2b1dd72.js";const i={},d=s(`<h1 id="sql优化" tabindex="-1"><a class="header-anchor" href="#sql优化" aria-hidden="true">#</a> SQL优化</h1><blockquote><p>和索引的优化关系很大</p></blockquote><h3 id="_1⃣️-插入数据" tabindex="-1"><a class="header-anchor" href="#_1⃣️-插入数据" aria-hidden="true">#</a> 1⃣️ 插入数据</h3><h4 id="insert优化" tabindex="-1"><a class="header-anchor" href="#insert优化" aria-hidden="true">#</a> insert优化</h4><h5 id="_1-批量插入" tabindex="-1"><a class="header-anchor" href="#_1-批量插入" aria-hidden="true">#</a> 1. 批量插入</h5><p><code>insert into tb_test values(1, &#39;Tom&#39;),(2, &#39;Cat&#39;),(3, &#39;Jerry&#39;);</code></p><h5 id="_2-手动提交事务" tabindex="-1"><a class="header-anchor" href="#_2-手动提交事务" aria-hidden="true">#</a> 2. 手动提交事务</h5><p>避免频发提交事务</p><p><code>start transaction;</code></p><p><code>...</code></p><p><code>commit;</code></p><h5 id="_3-主键顺序插入" tabindex="-1"><a class="header-anchor" href="#_3-主键顺序插入" aria-hidden="true">#</a> 3. 主键顺序插入</h5><p>比乱序插入效率更高</p><h4 id="大批量插入数据" tabindex="-1"><a class="header-anchor" href="#大批量插入数据" aria-hidden="true">#</a> 大批量插入数据</h4><p>不用 <code>insert</code> 而用 <code>load</code></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 客户端连接服务器时，加上参数 --local-infile</span>
mysql <span class="token comment">--local-infile -u root -p</span>

<span class="token comment">-- 设置全局参数locat_infile = 1，开启从本地加载文件导入数据的开关</span>
<span class="token keyword">set</span> <span class="token keyword">global</span> locat_infile <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">-- 执行load指令将准备好的数据，加载到表结构中</span>
<span class="token comment">-- 原来的数据 ， 分割，加之后 \\n 分割</span>
<span class="token keyword">load</span> <span class="token keyword">data</span> <span class="token keyword">local</span> <span class="token keyword">infile</span> <span class="token string">&#39;/root/sql1.log&#39;</span> <span class="token keyword">into</span> <span class="token keyword">table</span> <span class="token string">&#39;tb_user&#39;</span> <span class="token keyword">fields</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;,&#39;</span> <span class="token keyword">lines</span> <span class="token keyword">terminated</span> <span class="token keyword">by</span> <span class="token string">&#39;\\n&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2⃣️-主键优化" tabindex="-1"><a class="header-anchor" href="#_2⃣️-主键优化" aria-hidden="true">#</a> 2⃣️ 主键优化</h3><h4 id="数据组织方式" tabindex="-1"><a class="header-anchor" href="#数据组织方式" aria-hidden="true">#</a> 数据组织方式</h4><p>在InnoDB存储引擎中，表数据根据主键顺序组织存储，这种表称为索引组织表 IOT</p><h5 id="页分裂" tabindex="-1"><a class="header-anchor" href="#页分裂" aria-hidden="true">#</a> 页分裂</h5><p>主键乱序插入</p><h5 id="页合并" tabindex="-1"><a class="header-anchor" href="#页合并" aria-hidden="true">#</a> 页合并</h5><p>删除数据时，不会真的被删除，而是被flagged为删除、空间允许其他记录声明</p><p>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%，在创建表或索引的时候指定），InnoDB就会寻找前后页看是否可以优化空间使用</p><h4 id="主键设计原则" tabindex="-1"><a class="header-anchor" href="#主键设计原则" aria-hidden="true">#</a> 主键设计原则</h4><ul><li>尽量降低主键长度，因为可能有较多二级索引</li><li>插入数据时尽量顺序插入，使用AUTO_INCREMENT自增主键</li><li>尽量不要使用UUID或者其他自然主键，如身份证（乱序）</li><li>业务操作中，避免修改主键</li></ul><h3 id="_3⃣️-order-by优化" tabindex="-1"><a class="header-anchor" href="#_3⃣️-order-by优化" aria-hidden="true">#</a> 3⃣️ order by优化</h3><p>尽量要用Using index，而不是Using filesort（所有不是通过索引直接返回排序结果的排序，需要在排序缓冲区中排序）</p><p><code>create index idx_user_age__pho_ad on tb_user(age asc, phone desc);</code></p><p>age从小到大、phone从大到小：collation列A/D</p><p>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230106170817577.png" alt="image-20230106170817577" loading="lazy"></p><h3 id="_4⃣️-group-by优化" tabindex="-1"><a class="header-anchor" href="#_4⃣️-group-by优化" aria-hidden="true">#</a> 4⃣️ group by优化</h3><p>多字段分组，也需要满足最左前缀法则</p><h3 id="_5⃣️-limit优化" tabindex="-1"><a class="header-anchor" href="#_5⃣️-limit优化" aria-hidden="true">#</a> 5⃣️ limit优化</h3><p>分页操作，越往后查询效率越低</p><p>限制展示的数据数量</p><p><code>select xxx form tb_Xxx limit 100,10;</code></p><p>意思是从第100条开始查10条</p><p>优化：创建覆盖索引、子查询</p><h3 id="_6⃣️-count优化" tabindex="-1"><a class="header-anchor" href="#_6⃣️-count优化" aria-hidden="true">#</a> 6⃣️ count优化</h3><p>MyISAM引擎将表的总行数存储在磁盘上，执行count(*)直接返回这个数，效率很高</p><p>InnoDB只能一行一行读出来、再计数</p><p>优化：自己计数</p><h5 id="count-函数" tabindex="-1"><a class="header-anchor" href="#count-函数" aria-hidden="true">#</a> count()函数</h5><p>不计 null</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230106173417077.png" alt="image-20230106173417077" loading="lazy"></p><p>效率</p><p><strong>Count(*) 约等于 count(1) &gt; count(主键) &gt; count(字段)</strong></p><p>尽量用count(*)，因为数据库专门做了优化</p><h3 id="_7⃣️-update优化" tabindex="-1"><a class="header-anchor" href="#_7⃣️-update优化" aria-hidden="true">#</a> 7⃣️ update优化</h3><p>InnoDB的行锁是针对索引加的锁，而不是针对记录加的锁，并且该索引不能失效，否则升级为表锁，降低并发性能</p>`,52),r=[d];function t(o,c){return e(),n("div",null,r)}const l=a(i,[["render",t],["__file","1.html.vue"]]);export{l as default};
