import{_ as a,V as h,W as e,a0 as i}from"./framework-91a010c2.js";const n={},c=i('<h1 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap" aria-hidden="true">#</a> HashMap</h1><h2 id="高频面试题" tabindex="-1"><a class="header-anchor" href="#高频面试题" aria-hidden="true">#</a> 高频面试题</h2><h3 id="_1⃣️-底层数据结构" tabindex="-1"><a class="header-anchor" href="#_1⃣️-底层数据结构" aria-hidden="true">#</a> 1⃣️ 底层数据结构？</h3><p>1.7 数组 + 链表</p><p>1.8 数组 + 链表 ｜ 红黑树 （根据数据量多少而转换）</p><h3 id="_2⃣️-为什么红黑树-为什么一上来不树化-要转化-为什么阈值是8-什么时候树化-什么时候退化成链表" tabindex="-1"><a class="header-anchor" href="#_2⃣️-为什么红黑树-为什么一上来不树化-要转化-为什么阈值是8-什么时候树化-什么时候退化成链表" aria-hidden="true">#</a> 2⃣️ 为什么红黑树？为什么一上来不树化，要转化？为什么阈值是8？什么时候树化，什么时候退化成链表？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203153742311.png" alt="image-20230203153742311" loading="lazy"></p><p>退化的判定：移除之前</p><p>链表太长影响查询性能</p><p>因为容量较小时，树化性能没有优势</p><p>红黑树底层是TreeNode，内存占用更多</p><h4 id="快速查找" tabindex="-1"><a class="header-anchor" href="#快速查找" aria-hidden="true">#</a> 快速查找</h4><p>计算哈希码 - 少量比较</p><h4 id="树化条件" tabindex="-1"><a class="header-anchor" href="#树化条件" aria-hidden="true">#</a> 树化条件</h4><ol><li><p>链表长度 &gt; 8</p><blockquote><p>但是链表长度可能超过8，因为如果总容量不够64，就不会树化</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203134950662.png" alt="image-20230203134950662" loading="lazy"></p></li><li><p>树容量 &gt; 64</p></li></ol><h3 id="_3⃣️-索引计算方法-有hashcode-为什么要提供hash-方法-数组容量为什么是2的n次幂" tabindex="-1"><a class="header-anchor" href="#_3⃣️-索引计算方法-有hashcode-为什么要提供hash-方法-数组容量为什么是2的n次幂" aria-hidden="true">#</a> 3⃣️ 索引计算方法？有hashcode，为什么要提供hash()方法？数组容量为什么是2的n次幂？</h3><p>容量 -1取模</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203154657869.png" alt="image-20230203154657869" loading="lazy"></p><p>数组容量2的n次幂：虽然<strong>计算效率</strong>高，但是结果的分布性不好</p><blockquote><p>如全是偶数的极端情况</p></blockquote><p>数组容量选质数，哈希分布性更好</p><p><code>int[] sizes = {23};</code></p><h3 id="_4⃣️-put方法流程-1-7-1-8版本的差异" tabindex="-1"><a class="header-anchor" href="#_4⃣️-put方法流程-1-7-1-8版本的差异" aria-hidden="true">#</a> 4⃣️ put方法流程，1.7，1.8版本的差异？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203160902816.png" alt="image-20230203160902816" loading="lazy"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203161137459.png" alt="image-20230203161137459" loading="lazy"></p><h3 id="_5⃣️-加载因子-扩容因子-为什么默认是0-75f" tabindex="-1"><a class="header-anchor" href="#_5⃣️-加载因子-扩容因子-为什么默认是0-75f" aria-hidden="true">#</a> 5⃣️ 加载因子 / 扩容因子 为什么默认是0.75f？</h3><p>factor</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203161430998.png" alt="image-20230203161430998" loading="lazy"></p><h3 id="_6⃣️-多线程可能出现的问题" tabindex="-1"><a class="header-anchor" href="#_6⃣️-多线程可能出现的问题" aria-hidden="true">#</a> 6⃣️ 多线程可能出现的问题？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203162157335.png" alt="image-20230203162157335" loading="lazy"></p><p>没太懂。。</p><h3 id="_7⃣️-key可以null吗-key的对象有什么要求" tabindex="-1"><a class="header-anchor" href="#_7⃣️-key可以null吗-key的对象有什么要求" aria-hidden="true">#</a> 7⃣️ key可以null吗，key的对象有什么要求？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203174642322.png" alt="image-20230203174642322" loading="lazy"></p><h3 id="_8⃣️-string对象的hashcode-如何设计-为什么每次乘31" tabindex="-1"><a class="header-anchor" href="#_8⃣️-string对象的hashcode-如何设计-为什么每次乘31" aria-hidden="true">#</a> 8⃣️ String对象的hashCode()如何设计？为什么每次乘31？</h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203174721597.png" alt="image-20230203174721597" loading="lazy"></p><p>并且31可以转化为移位加减法</p>',36),t=[c];function d(s,p){return h(),e("div",null,t)}const o=a(n,[["render",d],["__file","2 HashMap.html.vue"]]);export{o as default};
