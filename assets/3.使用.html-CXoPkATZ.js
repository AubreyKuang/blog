import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as n}from"./app-CA3Si4S1.js";const t={};function p(h,s){return n(),a("div",null,s[0]||(s[0]=[e(`<h1 id="使用规则" tabindex="-1"><a class="header-anchor" href="#使用规则"><span>使用规则</span></a></h1><p>将错乱的表转化为行显示：<code>\\G</code></p><p>创建索引：<code>create idex idx_sku_sn on tb_sku(sn);</code></p><h4 id="最左前缀法则" tabindex="-1"><a class="header-anchor" href="#最左前缀法则"><span>最左前缀法则</span></a></h4><p>主要针对联合索引（索引了多列）：从索引的最左列开始，并且不跳过中间的列</p><blockquote><p>最左边的一定要存在，后面的列不存在也可能走这个联合索引</p><p>如果中间的跳过了，索引会部分失效（索引长度变小）</p></blockquote><h4 id="范围查询" tabindex="-1"><a class="header-anchor" href="#范围查询"><span>范围查询</span></a></h4><p>范围查询的字段的右边的列，索引失效</p><p><strong>用大于等于、小于等于</strong>，则不会</p><h4 id="几种索引失效情况" tabindex="-1"><a class="header-anchor" href="#几种索引失效情况"><span>几种索引失效情况</span></a></h4><h5 id="_1⃣️-在索引列运算" tabindex="-1"><a class="header-anchor" href="#_1⃣️-在索引列运算"><span>1⃣️ 在索引列运算</span></a></h5><p><code>select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;</code></p><p>对于11位的手机号、最后两位为15</p><h5 id="_2⃣️-字符串不加引号" tabindex="-1"><a class="header-anchor" href="#_2⃣️-字符串不加引号"><span>2⃣️ 字符串不加引号</span></a></h5><p>字符串类型使用索引，不加引号就不会走索引</p><h5 id="_3⃣️-or连接的条件" tabindex="-1"><a class="header-anchor" href="#_3⃣️-or连接的条件"><span>3⃣️ or连接的条件</span></a></h5><p>如果or前的条件的列有索引，<strong>后面没索引</strong>，那么涉及到的都不会用索引</p><h5 id="_4⃣️-数据分布影响" tabindex="-1"><a class="header-anchor" href="#_4⃣️-数据分布影响"><span>4⃣️ 数据分布影响</span></a></h5><p>如果MySQ评估使用索引比全表扫描更慢，就不会使用索引</p><h4 id="模糊查询" tabindex="-1"><a class="header-anchor" href="#模糊查询"><span>模糊查询</span></a></h4><p>头部模糊查询：可以</p><p><code>select * from tb_user where profession like &#39;信息%&#39;;</code></p><p>尾部模糊查询：失效</p><p><code>select * from tb_user where profession like &#39;%管理&#39;;</code></p><blockquote><p>前面不能加百分号</p></blockquote><h4 id="sql提示" tabindex="-1"><a class="header-anchor" href="#sql提示"><span>SQL提示</span></a></h4><p>优化数据库的重要手段</p><p>在sql语句中加入一些认为的提示来优化操作</p><blockquote><p>例如指定使用的查询</p></blockquote><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- use index 建议这个索引:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">use</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(index_user_pro) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- ignore index:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">ignore</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(index_user_pro) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- force index 必须用这个index:</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">explain </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> * </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_user </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">force</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> index</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(index_user_pro) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">where</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> ...;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引"><span>覆盖索引</span></a></h4><p>尽量使用覆盖索引（查询使用了索引，并且<strong>需要返回的列</strong>，在该索引中能够全部找到）</p><p>减少 <code>select *</code>，因为很容易就会回表查询</p><p><code>using index condition </code>：查找使用了索引，但是需要回表查询</p><p><code>using where, using index </code>：查找使用了索引，但是需要的数据都在索引列中，不需要回表查询</p><p>问题：</p><p>优化<code>select id,username,password form tb_user where username = &#39;it&#39;</code></p><p>解答：</p><p>建立 username 和 password的联合索引，这样二级索引下面挂的就是id，直接覆盖索引，不需要回表查询</p><h4 id="前缀索引" tabindex="-1"><a class="header-anchor" href="#前缀索引"><span>前缀索引</span></a></h4><p>当字段类型为字符串（varchar，text等），如果字符串很长，索引就会很大。查询时占用磁盘io，降低查询效率</p><p>可以将字符串的一部分前缀建立索引</p><p><code>create index idx_xxx on table_name(column(n));</code></p><p>n表示提取前几个字符</p><h5 id="前缀长度" tabindex="-1"><a class="header-anchor" href="#前缀长度"><span>前缀长度</span></a></h5><p>根据索引的选择性决定：不重复的索引值（基数）和数据表的记录总数的比值</p><p>⬆️越高则查询效率越高</p><p>唯一索引的选择性是1，性能最好</p><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">distinct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> email)/</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(*) </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">from</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> tb_user;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- substring从第一个开始截取、前5个，分别看选择性</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">select</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">distinct</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> substring</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(emai, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">, </span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">))/</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;">count</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(*) form tb_user;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="单列索引与联合索引" tabindex="-1"><a class="header-anchor" href="#单列索引与联合索引"><span>单列索引与联合索引</span></a></h4><p>如果存在多个查询条件，建议联合索引</p>`,51)]))}const d=i(t,[["render",p]]),k=JSON.parse(`{"path":"/cs/database/mysql/%F0%9F%93%93%203%20%E7%B4%A2%E5%BC%95/3.%E4%BD%BF%E7%94%A8.html","title":"使用规则","lang":"en-US","frontmatter":{"description":"使用规则 将错乱的表转化为行显示：\\\\G 创建索引：create idex idx_sku_sn on tb_sku(sn); 最左前缀法则 主要针对联合索引（索引了多列）：从索引的最左列开始，并且不跳过中间的列 最左边的一定要存在，后面的列不存在也可能走这个联合索引 如果中间的跳过了，索引会部分失效（索引长度变小） 范围查询 范围查询的字段的右边的列，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用规则\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-04-06T03:21:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aubrey\\",\\"url\\":\\"https://github.com/aubreykuang\\"}]}"],["meta",{"property":"og:url","content":"https://aubreykuang.github.io/blog/blog/cs/database/mysql/%F0%9F%93%93%203%20%E7%B4%A2%E5%BC%95/3.%E4%BD%BF%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"Aubrey's Blog"}],["meta",{"property":"og:title","content":"使用规则"}],["meta",{"property":"og:description","content":"使用规则 将错乱的表转化为行显示：\\\\G 创建索引：create idex idx_sku_sn on tb_sku(sn); 最左前缀法则 主要针对联合索引（索引了多列）：从索引的最左列开始，并且不跳过中间的列 最左边的一定要存在，后面的列不存在也可能走这个联合索引 如果中间的跳过了，索引会部分失效（索引长度变小） 范围查询 范围查询的字段的右边的列，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-04-06T03:21:04.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-06T03:21:04.000Z"}]]},"git":{"createdTime":1672889300000,"updatedTime":1680751264000,"contributors":[{"name":"KoryKL","username":"KoryKL","email":"1274994508@qq.com","commits":4,"url":"https://github.com/KoryKL"}]},"readingTime":{"minutes":2.5,"words":751},"filePathRelative":"cs/database/mysql/📓 3 索引/3.使用.md","excerpt":"\\n<p>将错乱的表转化为行显示：<code>\\\\G</code></p>\\n<p>创建索引：<code>create idex idx_sku_sn on tb_sku(sn);</code></p>\\n<h4>最左前缀法则</h4>\\n<p>主要针对联合索引（索引了多列）：从索引的最左列开始，并且不跳过中间的列</p>\\n<blockquote>\\n<p>最左边的一定要存在，后面的列不存在也可能走这个联合索引</p>\\n<p>如果中间的跳过了，索引会部分失效（索引长度变小）</p>\\n</blockquote>\\n<h4>范围查询</h4>\\n<p>范围查询的字段的右边的列，索引失效</p>\\n<p><strong>用大于等于、小于等于</strong>，则不会</p>","autoDesc":true}`);export{d as comp,k as data};
