import{_ as a,V as e,W as n,a0 as d}from"./framework-91a010c2.js";const o={},i=d(`<h1 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h1><p>定义：计算机协调多个进程或线程并发访问某一资源的机制</p><p>出了传统的计算资源（CPU、RAM、I/O）的争用外，数据也是供许多用户共享的资源</p><p>锁冲突也是影响数据库并发访问性能的重要因素</p><p>MySQL中，按照锁的粒度分为以下三类：</p><h3 id="_1⃣️-全局锁" tabindex="-1"><a class="header-anchor" href="#_1⃣️-全局锁" aria-hidden="true">#</a> 1⃣️ 全局锁</h3><p>锁定数据库中所有表</p><p>所有数据就只读，后续的DML的写入语句、DDL、更新操作的事务提交语句都会被阻塞</p><p>典型应用：全库的逻辑备份，获取一致性视图、保证数据完整性、一致性</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230107180700388.png" alt="image-20230107180700388" loading="lazy"></p><h4 id="备份过程" tabindex="-1"><a class="header-anchor" href="#备份过程" aria-hidden="true">#</a> 备份过程</h4><ol><li><p>对当前数据库加全局锁：<code>flush tales with read lock;</code></p></li><li><p>借助工具、输入<code>-u</code>账号<code>-p</code>密码、存储路径、存储的文件名<code>mysqldump -uroot -ppassword data &gt; Desktop\\data.sql</code></p><blockquote><p>这一步不能在MySQL命令行中进行，应该在普通命令行中</p><p><code>-h</code>指定主机地址</p><p><code>mysqldump -hxxx.xxx.xxx -uroot -ppassword data &gt; Desktop\\data.sql</code></p></blockquote></li><li><p>解锁：<code>unlock tables;</code></p></li></ol><h4 id="问题" tabindex="-1"><a class="header-anchor" href="#问题" aria-hidden="true">#</a> 问题</h4><ol><li>如果在主库上备份，期间都不能更新，业务停摆</li><li>如果在从库上备份，期间都不能执行主库同步过来的二进制日志（binlog），导致主从延迟</li></ol><blockquote><p>在InnoDB引擎中，可以在备份时加上参数 --single-transaction 完成不加锁的一致性数据备份</p><p><code>mysqldump --single-transaction -uroot -ppassowrd it &gt; it.sql</code></p></blockquote><h3 id="_2⃣️-表级锁" tabindex="-1"><a class="header-anchor" href="#_2⃣️-表级锁" aria-hidden="true">#</a> 2⃣️ 表级锁</h3><p>每次操作锁住整张表</p><p>发生锁冲突的概率最高、并发度最低</p><p>应用在MyISAM, InnoDB, BDB等存储引擎中</p><p>表级锁分类：</p><h4 id="_1-表锁" tabindex="-1"><a class="header-anchor" href="#_1-表锁" aria-hidden="true">#</a> 1 表锁</h4><h5 id="_1-表共享读锁-read-lock" tabindex="-1"><a class="header-anchor" href="#_1-表共享读锁-read-lock" aria-hidden="true">#</a> 1. 表共享读锁 read lock</h5><p>不阻塞读，但是阻塞写（对其他客户端也是）</p><p>直到unlock，才会结束阻塞</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230108194520129.png" alt="image-20230108194520129" loading="lazy"></p><h5 id="_2-表独占写锁-write-lock" tabindex="-1"><a class="header-anchor" href="#_2-表独占写锁-write-lock" aria-hidden="true">#</a> 2. 表独占写锁 write lock</h5><p>自己可以读可以写，其他客户端不能读不能写</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230108194548918.png" alt="image-20230108194548918" loading="lazy"></p><p>语法：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token comment">-- 加锁</span>
<span class="token keyword">lock</span> <span class="token keyword">tables</span> 表名 <span class="token keyword">read</span> <span class="token operator">/</span> <span class="token keyword">write</span>

<span class="token comment">-- 解锁</span>
<span class="token keyword">unlock</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>
<span class="token comment">-- 或者将客户端断开，就会自动解锁</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="元数据锁-meta-data-lock-mdl" tabindex="-1"><a class="header-anchor" href="#元数据锁-meta-data-lock-mdl" aria-hidden="true">#</a> 元数据锁（meta data lock, MDL）</h4><p>系统自动控制，不用显式使用，访问一张表的时候自动加上</p><p>作用：维护表元数据的数据一致性、避免DML和DDL冲突，保证读写的正确性</p><p>表上有活动事务时，不可以对元数据执行写入</p><blockquote><p>元数据可以理解为表结构</p><p>MySQL5.5后引入MDL，对一张表crud时，加MDL读锁（共享）；变更表结构时，加MDL写锁（排他）</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230108195350325.png" alt="image-20230108195350325" loading="lazy"></p><p>例子：有一个在查询，另一个客户端的update就会被阻塞</p><h4 id="_2-意向锁" tabindex="-1"><a class="header-anchor" href="#_2-意向锁" aria-hidden="true">#</a> 2 意向锁</h4><p>避免执行DML时，行锁与表锁的冲突，在InnoDB中加入了意向锁</p><p>表锁不用检查每行数据是否加锁</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230108204239158.png" alt="image-20230108204239158" loading="lazy"></p><blockquote><p>阻塞到线程A提交，意向锁释放</p></blockquote><p>意向锁分类：</p><h5 id="_1-意向共享锁-is" tabindex="-1"><a class="header-anchor" href="#_1-意向共享锁-is" aria-hidden="true">#</a> 1. 意向共享锁 IS</h5><p>添加语句：<code>selcect...lock in share mode</code></p><p>与表锁共享锁read兼容，与表锁排他锁write互斥</p><h5 id="_2-意向排他锁-ix" tabindex="-1"><a class="header-anchor" href="#_2-意向排他锁-ix" aria-hidden="true">#</a> 2. 意向排他锁 IX</h5><p>添加：<code>insert, update, delete, select...for update</code></p><p>与表锁共享锁read、表锁排他锁write都互斥</p><p><strong>意向锁之间不会互斥</strong></p><h5 id="测试" tabindex="-1"><a class="header-anchor" href="#测试" aria-hidden="true">#</a> 测试</h5><p>在select语句后面加 <code>lock in share mode</code>，表示会加上这一行的共享锁</p><h5 id="查询锁" tabindex="-1"><a class="header-anchor" href="#查询锁" aria-hidden="true">#</a> 查询锁</h5><p><code>select object_schema, object_name, index_name, lock_type, lock_mode, lock_data from performance_schema.data_locks;</code></p><h3 id="_3⃣️-行级锁" tabindex="-1"><a class="header-anchor" href="#_3⃣️-行级锁" aria-hidden="true">#</a> 3⃣️ 行级锁</h3><p>每次操作锁住对应的行数据</p><p>锁定粒度最小，发生锁冲突的概率最低、并发度最高</p><p>应用在InnoDB存储引擎中（事务、外键、行级锁）</p><p>InnoDB的数据是基于索引组织的，行锁是通过对索引项加锁实现，而不是对记录加锁</p><p>分类：</p><h4 id="_1-行锁-record-lock" tabindex="-1"><a class="header-anchor" href="#_1-行锁-record-lock" aria-hidden="true">#</a> 1 行锁（record lock）</h4><p>锁定<strong>单个行记录</strong>，防止其他事务update, delete</p><p>在RC、RR隔离级别下都支持</p><h5 id="_1-共享锁-s" tabindex="-1"><a class="header-anchor" href="#_1-共享锁-s" aria-hidden="true">#</a> 1. 共享锁（S）</h5><p>允许一个事务读一行，组织其他事务获得相同数据集的排他锁</p><h5 id="_2-排他锁-x" tabindex="-1"><a class="header-anchor" href="#_2-排他锁-x" aria-hidden="true">#</a> 2. 排他锁（X）</h5><p>允许获取排他锁的事务更新数据，组织其他事务获得相同数据集的共享锁、排他锁</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230108223950191.png" alt="image-20230108223950191" loading="lazy"></p><h5 id="常见的crud加的行锁类型" tabindex="-1"><a class="header-anchor" href="#常见的crud加的行锁类型" aria-hidden="true">#</a> 常见的crud加的行锁类型</h5><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230108224048165.png" alt="image-20230108224048165" loading="lazy"></p><h4 id="_2-间隙锁-gap-lock" tabindex="-1"><a class="header-anchor" href="#_2-间隙锁-gap-lock" aria-hidden="true">#</a> 2 间隙锁（gap lock）</h4><p>锁定索引记录间隙（不包含记录），防止其他事务对间隙insert，产生幻读</p><p>间隙锁可以共存，一个事务的间隙锁不会组织另一个事务在同一间隙上采用间隙锁</p><p>在RR级别下支持</p><blockquote><p>InnoDB默认RR级别运行，使用临键锁进行搜索和索引扫描、以防幻读</p><ol><li>索引上的等值查询（唯一索引）：给不存在的记录加锁，优化为间隙锁</li><li>索引上的等值查询（普通索引）：向右遍历，最后一个值不满足查询需求时，next-key lock退化为间隙锁</li><li>索引上的范围查询（唯一索引）：访问到不满足条件的第一个值为止</li></ol></blockquote><h4 id="_3-临键锁-next-key-lock" tabindex="-1"><a class="header-anchor" href="#_3-临键锁-next-key-lock" aria-hidden="true">#</a> 3 临键锁（next-key lock）</h4><p>行锁和间隙锁的组合，同时锁住数据、数据前面的间隙</p><p>在RR级别下支持</p><blockquote><p>InnoDB默认RR级别运行，使用临键锁进行搜索和索引扫描、以防幻读</p><ol><li>针对唯一索引检索，对已存在的记录等值匹配时，自动优化为行锁</li><li>InnoDB行锁是针对索引加的锁，不通过索引检索数据，那么InnoDB将对所有记录加锁，<strong>升级为表锁</strong></li></ol></blockquote>`,79),c=[i];function p(s,r){return e(),n("div",null,c)}const l=a(o,[["render",p],["__file","1.html.vue"]]);export{l as default};
