import{_ as e,V as a,W as o,a0 as r}from"./framework-91a010c2.js";const n={},t=r('<h1 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h1><h2 id="基本数据类型" tabindex="-1"><a class="header-anchor" href="#基本数据类型" aria-hidden="true">#</a> 基本数据类型</h2><p><img src="https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230424110028070.png" alt="image-20230424110028070" loading="lazy"></p><blockquote><p>java 中使用 long 类型的数据一定要在数值后面加 L，否则将作为整型解析</p></blockquote><p>对应的包装类型：Byte, Short, Integer, Long, Float, Double, Character, Boolean</p><h3 id="与包装类型的区别" tabindex="-1"><a class="header-anchor" href="#与包装类型的区别" aria-hidden="true">#</a> 与包装类型的区别</h3><ol><li>包装类型不赋值为 null，基本类型有默认值</li><li>jvm 层面，基本数据类型直接放在 java 虚拟机栈的局部变量表中（占用更小空间），包装类型属于对象类型，对象类型实例存在堆中</li></ol><h4 id="包装类型的常量池技术" tabindex="-1"><a class="header-anchor" href="#包装类型的常量池技术" aria-hidden="true">#</a> 包装类型的常量池技术</h4><p>Byte, Short, Integer, Long 默认创建了数值 [-128, 127] 的相应类型的缓存数据，Character 创建数值在 [0, 127] 的相应范围的缓存数据，Boolean 返回 true/false</p><p>当代码中出现这些数值时，会直接使用缓存中的对象。如果在这个区域外，都会在堆上产生，所以建议用 <code>equals</code>方法判断</p><p>两种浮点数类型的包装类 Float, Double 没有实现常量池技术</p><blockquote><p>答案为 False</p><p><img src="https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230424111057085.png" alt="image-20230424111057085" loading="lazy"></p></blockquote><h4 id="包装类型的意义" tabindex="-1"><a class="header-anchor" href="#包装类型的意义" aria-hidden="true">#</a> 包装类型的意义？</h4><p>Java中的包装类型是为了将基本数据类型转换为对象而设计的。这些包装类型提供了一些额外的功能，例如可以将基本数据类型转换为对象，可以在集合中存储基本数据类型，可以使用null值表示缺少值等等。</p><p>此外，包装类型还提供了一些有用的方法，例如将字符串转换为基本数据类型，将基本数据类型转换为字符串等等。</p><p>在实际编程中，我们通常使用基本数据类型来表示简单的数据，但是在某些情况下，我们需要将基本数据类型转换为对象，这时就需要使用包装类型。</p><h3 id="自动拆装箱" tabindex="-1"><a class="header-anchor" href="#自动拆装箱" aria-hidden="true">#</a> 自动拆装箱</h3><p>基本数据类型和包装类型的转换</p><p>装箱：调用包装类的 valueOf()</p><p>拆箱：xxxValue() 方法</p><p><strong>频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p><h4 id="自动拆箱引发的-npe-问题" tabindex="-1"><a class="header-anchor" href="#自动拆箱引发的-npe-问题" aria-hidden="true">#</a> 自动拆箱引发的 NPE 问题</h4><p>自动拆箱是将包装类型转换为其对应的基本类型的过程。当一个包装类型的值为 <code>null</code> 时，自动拆箱会引发 <code>NullPointerException</code>。</p><p>这是因为基本类型不能为 <code>null</code>，所以在自动拆箱时，编译器会尝试访问一个 <code>null</code> 值的属性或方法，从而导致异常的抛出。为了避免这种情况，可以在自动拆箱之前检查包装类型是否为 <code>null</code>。</p>',24),l=[t];function d(i,c){return a(),o("div",null,l)}const p=e(n,[["render",d],["__file","0 数据类型.html.vue"]]);export{p as default};
