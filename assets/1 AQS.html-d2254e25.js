import{_ as t,V as o,W as c,X as s,Y as n,$ as e,a0 as l,E as p}from"./framework-91a010c2.js";const i={},d=s("h1",{id:"abstractqueuedsynchronizer",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#abstractqueuedsynchronizer","aria-hidden":"true"},"#"),n(" AbstractQueuedSynchronizer")],-1),r={href:"http://AQS.md",target:"_blank",rel:"noopener noreferrer"},k={href:"http://AQS.md",target:"_blank",rel:"noopener noreferrer"},u=l(`<p>它为大多数通过单个 int 类型的原子值来表示状态的同步器提供了实现基础。子类必须重写更改同步器状态的 protected 方法，并定义该状态在获取或释放子类对象方面的具体含义。</p><p>此类中的其他方法实现所有排队和阻塞机制。子类可以维护其他状态字段，但就同步而言，只有使用了方法 getState、 setState 和 compareAndSetState 操作以原子方式更新的 int 值才能够被跟踪。</p><h2 id="设计" tabindex="-1"><a class="header-anchor" href="#设计" aria-hidden="true">#</a> 设计</h2><p>AQS 本质上是一个 FIFO 的双向队列，线程被包装成结点的形式，基于自旋机制在队列中等待获取资源（这里的资源可以简单理解为对象锁）</p><p><img src="https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230425122431216.png" alt="image-20230425122431216" loading="lazy"></p><p>使用一个 volatile 修饰的 int 类型的 state 表示同步状态,通过内置的 FIFO 队列 CLH 完成资源获取的排队工作, 将资源封装为 Node ,通过 cas 改变 state 值</p><p>AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。</p><h3 id="同步队列-clh" tabindex="-1"><a class="header-anchor" href="#同步队列-clh" aria-hidden="true">#</a> 同步队列｜CLH</h3><p>基于链表实现的双向队列，也是 CLH 锁的变种。CLH 锁是 AQS 队列同步器实现的基础。</p><ul><li>CLH 锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性。</li><li>CLH 队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</li></ul><h3 id="node" tabindex="-1"><a class="header-anchor" href="#node" aria-hidden="true">#</a> Node</h3><p>以内部类 <code>Node</code> 的形式定义了同步队列结点</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Node</span> <span class="token punctuation">{</span>

    <span class="token doc-comment comment">/** 模式定义 */</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">SHARED</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Node</span> <span class="token constant">EXCLUSIVE</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/** 线程状态 */</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CANCELLED</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">SIGNAL</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">CONDITION</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">PROPAGATE</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">;</span>

    <span class="token doc-comment comment">/** 线程等待状态 */</span>
    <span class="token keyword">volatile</span> <span class="token keyword">int</span> waitStatus<span class="token punctuation">;</span>

    <span class="token doc-comment comment">/** 前驱结点 */</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> prev<span class="token punctuation">;</span>
    <span class="token doc-comment comment">/** 后置结点 */</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span> next<span class="token punctuation">;</span>

    <span class="token doc-comment comment">/** 持有的线程对象 */</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Thread</span> thread<span class="token punctuation">;</span>

    <span class="token doc-comment comment">/** 对于独占模式而言，指向下一个处于 CONDITION 等待状态的结点；对于共享模式而言，则为 SHARED 结点 */</span>
    <span class="token class-name">Node</span> nextWaiter<span class="token punctuation">;</span>

    <span class="token comment">// ... 省略方法定义</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h2><p>用作同步器的基础，使用 getState()/setState()/cas 这些用于检查或修改同步状态的方法对下面的方法进行重新定义：</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p>这些方法默认抛出 UnsupportedOperationException, 这些方法内部必须保证线程安全，并且通常应该是简短且无锁的。 其他方法因为不能独立的变化，所以声明为 final。</p>`,17);function m(v,h){const a=p("ExternalLinkIcon");return o(),c("div",null,[d,s("p",null,[n("本类提供了一个用于实现阻塞锁和同步器（信号量、事件等）的框架，依 [1 "),s("a",r,[n("AQS.md"),e(a)]),n("](1 "),s("a",k,[n("AQS.md"),e(a)]),n(") 赖先进先出 (FIFO) 的等待队列来实现。")]),u])}const y=t(i,[["render",m],["__file","1 AQS.html.vue"]]);export{y as default};
