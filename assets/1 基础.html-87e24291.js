const e=JSON.parse(`{"key":"v-7c5d256d","path":"/cs/database/redis/1%20%E5%9F%BA%E7%A1%80.html","title":"Redis","lang":"en-US","frontmatter":{"description":"Redis 基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)等，并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。 支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等。","head":[["meta",{"property":"og:url","content":"https://korykl.github.io/blog/blog/cs/database/redis/1%20%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"Kory's Blog"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis 基于内存的数据库，对数据的读写操作都是在内存中完成，因此读写速度非常快，常用于缓存，消息队列、分布式锁等场景。 提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)等，并且对数据类型的操作都是原子性的，因为执行命令由单线程负责的，不存在并发竞争的问题。 支持事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制等等。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-04-26T09:43:18.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-04-26T09:43:18.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://korykl.github.io/blog/blog/zh/cs/database/redis/1%20%E5%9F%BA%E7%A1%80.html"}]]},"headers":[{"level":2,"title":"Redis数据结构","slug":"redis数据结构","link":"#redis数据结构","children":[{"level":3,"title":"String（字符串）","slug":"string-字符串","link":"#string-字符串","children":[]},{"level":3,"title":"Hash（哈希）","slug":"hash-哈希","link":"#hash-哈希","children":[]},{"level":3,"title":"List（列表）","slug":"list-列表","link":"#list-列表","children":[]},{"level":3,"title":"Set（集合）","slug":"set-集合","link":"#set-集合","children":[]},{"level":3,"title":"Zset（有序集合）","slug":"zset-有序集合","link":"#zset-有序集合","children":[]}]},{"level":2,"title":"Redis线程模型","slug":"redis线程模型","link":"#redis线程模型","children":[{"level":3,"title":"单线程","slug":"单线程","link":"#单线程","children":[]},{"level":3,"title":"初始化","slug":"初始化","link":"#初始化","children":[]},{"level":3,"title":"单线程还快的原因","slug":"单线程还快的原因","link":"#单线程还快的原因","children":[]},{"level":3,"title":"之前为什么单线程，为什么又多线程？","slug":"之前为什么单线程-为什么又多线程","link":"#之前为什么单线程-为什么又多线程","children":[]}]},{"level":2,"title":"Redis持久化","slug":"redis持久化","link":"#redis持久化","children":[{"level":3,"title":"1⃣️ AOF日志","slug":"_1⃣️-aof日志","link":"#_1⃣️-aof日志","children":[]},{"level":3,"title":"2⃣️ RDB 快照","slug":"_2⃣️-rdb-快照","link":"#_2⃣️-rdb-快照","children":[]},{"level":3,"title":"3⃣️ 混合持久化方式","slug":"_3⃣️-混合持久化方式","link":"#_3⃣️-混合持久化方式","children":[]}]},{"level":2,"title":"Redis过期删除与内存淘汰","slug":"redis过期删除与内存淘汰","link":"#redis过期删除与内存淘汰","children":[{"level":3,"title":"惰性删除","slug":"惰性删除","link":"#惰性删除","children":[]},{"level":3,"title":"定期删除","slug":"定期删除","link":"#定期删除","children":[]},{"level":3,"title":"如何处理过期键？","slug":"如何处理过期键","link":"#如何处理过期键","children":[]},{"level":3,"title":"","slug":"","link":"#","children":[]}]},{"level":2,"title":"Redis内存淘汰","slug":"redis内存淘汰","link":"#redis内存淘汰","children":[]}],"git":{"createdTime":1681027349000,"updatedTime":1682502198000,"contributors":[{"name":"KoryKL","email":"1274994508@qq.com","commits":2}]},"readingTime":{"minutes":26.31,"words":7893},"localizedDate":"April 9, 2023","filePathRelative":"cs/database/redis/1 基础.md","excerpt":"<h1> Redis</h1>\\n<p>基于内存的数据库，对数据的读写操作都是在内存中完成，因此<strong>读写速度非常快</strong>，常用于<strong>缓存，消息队列、分布式锁等场景</strong>。</p>\\n<p>提供了多种数据类型来支持不同的业务场景，比如 String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)等，并且对数据类型的操作都是<strong>原子性</strong>的，因为执行命令由单线程负责的，不存在并发竞争的问题。</p>\\n<p>支持<strong>事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制</strong>等等。</p>","autoDesc":true}`);export{e as data};
