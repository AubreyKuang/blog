import{_ as n,V as a,W as s,a0 as t}from"./framework-91a010c2.js";const e={},p=t(`<h1 id="基本" tabindex="-1"><a class="header-anchor" href="#基本" aria-hidden="true">#</a> 基本</h1><h2 id="使用" tabindex="-1"><a class="header-anchor" href="#使用" aria-hidden="true">#</a> 使用</h2><ul><li>针对目标函数，两边结果相反。一边true，一边false</li></ul><blockquote><p>二分搜索：找到这两段临界的那两个节点，故分类为寻找符合条件的<strong>最左侧</strong>的，和寻找符合条件的<strong>最右侧</strong>的这两种情况</p></blockquote><ul><li>在连续的整数区间使用 <ul><li>坐标位置或索引：数组中查找一个元素、隔板插入的空隙</li><li>一种资源或者能力：如最小或最大的花费、最大重复的子数组长度</li></ul></li></ul><h2 id="模版" tabindex="-1"><a class="header-anchor" href="#模版" aria-hidden="true">#</a> 模版</h2><h3 id="_1⃣️寻找符合条件的最前的" tabindex="-1"><a class="header-anchor" href="#_1⃣️寻找符合条件的最前的" aria-hidden="true">#</a> 1⃣️寻找符合条件的最前的</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">searchFirst</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">IntPredicate</span> isValid<span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isValid<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      end <span class="token operator">=</span> mid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      start <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> start<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="要点" tabindex="-1"><a class="header-anchor" href="#要点" aria-hidden="true">#</a> 要点</h4><ol><li><code>end = mid</code>，因为是搜索最靠前的一个，所以在mid符合条件时，因为右侧的符合条件的都大于mid，mid右侧的都可以排除，只需要在[start, mid]找</li><li><code>start = mid + 1</code>，mid不符合条件，本身可以排出，且这样写结合第四条可以避免死循环</li><li><code>mid = start + (end - start) / 2</code><ul><li>这样写可以避免整数溢出</li><li>这样写是向下取整，由于在循环内部时start&lt;end，这样可以保证mid小于end，这样end=mid可以缩小区间范围，start=mid+1也可以缩小区间范围避免死循环。</li></ul></li></ol><h4 id="用途" tabindex="-1"><a class="header-anchor" href="#用途" aria-hidden="true">#</a> 用途</h4><ol><li><p>排序数组、查找数字（或第一个位置）</p><p><code>int pos = searchFirst(0, nums.length - 1, (mid) -&gt; nums[mid] &gt;= target);</code></p><p><code>return nums[pos] == target ? pos : -1;</code></p></li><li><p>排序数组、查找数字（不存在则返回插入位置）</p><p>查找第一个大于等于的位置，所以直接返回pos</p><p><code>int pos = searchFirst(0, nums.length - 1, (mid) -&gt; nums[mid] &gt;= target);</code></p><p><code>return pos;</code></p></li></ol><h3 id="_2⃣️寻找符合条件的最后的" tabindex="-1"><a class="header-anchor" href="#_2⃣️寻找符合条件的最后的" aria-hidden="true">#</a> 2⃣️寻找符合条件的最后的</h3><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">int</span> <span class="token function">searchLast</span><span class="token punctuation">(</span><span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">,</span> <span class="token class-name">IntPredicate</span> isValid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mid <span class="token operator">=</span> start <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>isValid<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>mid<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      start <span class="token operator">=</span> mid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      end <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  
  <span class="token keyword">return</span> start<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="要求" tabindex="-1"><a class="header-anchor" href="#要求" aria-hidden="true">#</a> 要求</h4><ol><li><code>start = mid</code>，因为是搜索最靠后的一个，所以在mid符合条件时，因为左侧的符合条件的都小于mid，所以mid左侧的都可以排除，只需要在[mid, end]找</li><li><code>end = mid - 1</code>，mid不符合条件，本身可以排出，且这样写结合下一条可以避免死循环</li><li><code>mid = start + (end - start) / 2 + 1</code><ul><li>这样写是向上取整，由于在循环内部时start&lt;end，这样可以保证mid大于start，这样start=mid缩小区间范围，end=mid - 1可以也可以缩小区间范围避免死循环。</li><li>这样写可以避免整数溢出（有的时候start=0，end=Int的最大值，如果在括号内+1进行向上取整会溢出）</li></ul></li></ol><h4 id="用途-1" tabindex="-1"><a class="header-anchor" href="#用途-1" aria-hidden="true">#</a> 用途</h4>`,17),i=[p];function o(c,l){return a(),s("div",null,i)}const r=n(e,[["render",o],["__file","0.html.vue"]]);export{r as default};
