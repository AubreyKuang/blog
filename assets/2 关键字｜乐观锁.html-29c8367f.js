const e=JSON.parse(`{"key":"v-5ccf9bff","path":"/se/BackEnd/JVM/2%20%E5%85%B3%E9%94%AE%E5%AD%97%EF%BD%9C%E4%B9%90%E8%A7%82%E9%94%81.html","title":"关键字","lang":"en-US","frontmatter":{"description":"关键字 volatile 保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。","head":[["meta",{"property":"og:url","content":"https://korykl.github.io/blog/blog/se/BackEnd/JVM/2%20%E5%85%B3%E9%94%AE%E5%AD%97%EF%BD%9C%E4%B9%90%E8%A7%82%E9%94%81.html"}],["meta",{"property":"og:site_name","content":"Kory's Blog"}],["meta",{"property":"og:title","content":"关键字"}],["meta",{"property":"og:description","content":"关键字 volatile 保证变量的可见性，如果我们将变量声明为 volatile ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。 防止 JVM 的指令重排序。 如果我们将变量声明为 volatile ，在对这个变量进行读写操作的时候，会通过插入特定的 内存屏障 的方式来禁止指令重排序。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:updated_time","content":"2023-04-26T09:43:18.000Z"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:locale:alternate","content":"zh-CN"}],["meta",{"property":"article:modified_time","content":"2023-04-26T09:43:18.000Z"}],["link",{"rel":"alternate","hreflang":"zh-cn","href":"https://korykl.github.io/blog/blog/zh/se/BackEnd/JVM/2%20%E5%85%B3%E9%94%AE%E5%AD%97%EF%BD%9C%E4%B9%90%E8%A7%82%E9%94%81.html"}]]},"headers":[{"level":2,"title":"volatile","slug":"volatile","link":"#volatile","children":[{"level":3,"title":"不原子性","slug":"不原子性","link":"#不原子性","children":[]},{"level":3,"title":"双重校验锁实现单例模式","slug":"双重校验锁实现单例模式","link":"#双重校验锁实现单例模式","children":[]}]},{"level":2,"title":"乐观锁悲观锁","slug":"乐观锁悲观锁","link":"#乐观锁悲观锁","children":[{"level":3,"title":"悲观锁","slug":"悲观锁","link":"#悲观锁","children":[]},{"level":3,"title":"乐观锁","slug":"乐观锁","link":"#乐观锁","children":[]}]},{"level":2,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[{"level":3,"title":"使用方式","slug":"使用方式","link":"#使用方式","children":[]},{"level":3,"title":"可以修饰构造方法吗？","slug":"可以修饰构造方法吗","link":"#可以修饰构造方法吗","children":[]},{"level":3,"title":"底层原理？","slug":"底层原理","link":"#底层原理","children":[]}]}],"git":{"createdTime":1682502198000,"updatedTime":1682502198000,"contributors":[{"name":"KoryKL","email":"1274994508@qq.com","commits":1}]},"readingTime":{"minutes":8.61,"words":2582},"localizedDate":"April 26, 2023","filePathRelative":"se/BackEnd/JVM/2 关键字｜乐观锁.md","excerpt":"<h1> 关键字</h1>\\n<h2> volatile</h2>\\n<ul>\\n<li>\\n<p>保证变量的可见性，如果我们将变量声明为 <strong><code>volatile</code></strong> ，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。</p>\\n</li>\\n<li>\\n<p><strong>防止 JVM 的指令重排序。</strong> 如果我们将变量声明为 <strong><code>volatile</code></strong> ，在对这个变量进行读写操作的时候，会通过插入特定的 <strong>内存屏障</strong> 的方式来禁止指令重排序。</p>\\n</li>\\n</ul>","autoDesc":true}`);export{e as data};
