import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as p,o as n}from"./app-CA3Si4S1.js";const s={};function o(h,a){return n(),e("div",null,a[0]||(a[0]=[p('<h1 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h1><h2 id="高频面试题" tabindex="-1"><a class="header-anchor" href="#高频面试题"><span>高频面试题</span></a></h2><h3 id="_1⃣️-底层数据结构" tabindex="-1"><a class="header-anchor" href="#_1⃣️-底层数据结构"><span>1⃣️ 底层数据结构？</span></a></h3><p>1.7 数组 + 链表</p><p><strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p><p><strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p>1.8 数组 + 链表 ｜ 红黑树 （根据数据量多少而转换）</p><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><h3 id="_2⃣️-为什么红黑树-为什么一上来不树化-要转化-为什么阈值是8-什么时候树化-什么时候退化成链表" tabindex="-1"><a class="header-anchor" href="#_2⃣️-为什么红黑树-为什么一上来不树化-要转化-为什么阈值是8-什么时候树化-什么时候退化成链表"><span>2⃣️ 为什么红黑树？为什么一上来不树化，要转化？为什么阈值是8？什么时候树化，什么时候退化成链表？</span></a></h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203153742311.png" alt="image-20230203153742311"></p><p>退化的判定：移除之前</p><p>链表太长影响查询性能</p><p>因为容量较小时，树化性能没有优势</p><p>红黑树底层是TreeNode，内存占用更多</p><h4 id="快速查找" tabindex="-1"><a class="header-anchor" href="#快速查找"><span>快速查找</span></a></h4><p>计算哈希码 - 少量比较</p><h4 id="树化条件" tabindex="-1"><a class="header-anchor" href="#树化条件"><span>树化条件</span></a></h4><ol><li><p>链表长度 &gt; 8</p><blockquote><p>但是链表长度可能超过8，因为如果总容量不够64，就不会树化</p></blockquote><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203134950662.png" alt="image-20230203134950662"></p></li><li><p>树容量 &gt; 64</p></li></ol><h3 id="_3⃣️-索引计算方法-有hashcode-为什么要提供hash-方法-数组容量为什么是2的n次幂" tabindex="-1"><a class="header-anchor" href="#_3⃣️-索引计算方法-有hashcode-为什么要提供hash-方法-数组容量为什么是2的n次幂"><span>3⃣️ 索引计算方法？有hashcode，为什么要提供hash()方法？数组容量为什么是2的n次幂？</span></a></h3><p>容量 -1取模</p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203154657869.png" alt="image-20230203154657869"></p><p>数组容量2的n次幂：虽然<strong>计算效率</strong>高，但是结果的分布性不好</p><blockquote><p>如全是偶数的极端情况</p></blockquote><p>数组容量选质数，哈希分布性更好</p><p><code>int[] sizes = {23};</code></p><h3 id="_4⃣️-put方法流程-1-7-1-8版本的差异" tabindex="-1"><a class="header-anchor" href="#_4⃣️-put方法流程-1-7-1-8版本的差异"><span>4⃣️ put方法流程，1.7，1.8版本的差异？</span></a></h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203160902816.png" alt="image-20230203160902816"></p><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203161137459.png" alt="image-20230203161137459"></p><h3 id="_5⃣️-加载因子-扩容因子-为什么默认是0-75f" tabindex="-1"><a class="header-anchor" href="#_5⃣️-加载因子-扩容因子-为什么默认是0-75f"><span>5⃣️ 加载因子 / 扩容因子 为什么默认是0.75f？</span></a></h3><p>控制数组存放数据的疏密程度</p><p>loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。</strong></p><h3 id="_6⃣️-多线程可能出现的问题" tabindex="-1"><a class="header-anchor" href="#_6⃣️-多线程可能出现的问题"><span>6⃣️ 多线程可能出现的问题？</span></a></h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203162157335.png" alt="image-20230203162157335"></p><h3 id="_7⃣️-put方法" tabindex="-1"><a class="header-anchor" href="#_7⃣️-put方法"><span>7⃣️ put方法</span></a></h3><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><h3 id="_8⃣️-string对象的hashcode-如何设计-为什么每次乘31" tabindex="-1"><a class="header-anchor" href="#_8⃣️-string对象的hashcode-如何设计-为什么每次乘31"><span>8⃣️ String对象的hashCode()如何设计？为什么每次乘31？</span></a></h3><p><img src="https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203174721597.png" alt="image-20230203174721597"></p><p>并且31可以转化为移位加减法</p>',39)]))}const r=t(s,[["render",o]]),g=JSON.parse(`{"path":"/se/BackEnd/%F0%9F%8C%9F%20java%E9%9B%86%E5%90%88/1%20%E5%9F%BA%E7%A1%80/2%20HashMap.html","title":"HashMap","lang":"en-US","frontmatter":{"description":"HashMap 高频面试题 1⃣️ 底层数据结构？ 1.7 数组 + 链表 数组和链表 结合在一起使用也就是 链表散列。 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 1.8 数组 + 链表 ｜ 红黑树 （根据数据量多少而转换） 当链表长度大于阈值（默认为 8）时...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"HashMap\\",\\"image\\":[\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203153742311.png\\",\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203134950662.png\\",\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203154657869.png\\",\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203160902816.png\\",\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203161137459.png\\",\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203162157335.png\\",\\"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203174721597.png\\"],\\"dateModified\\":\\"2023-04-26T09:43:18.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aubrey\\",\\"url\\":\\"https://github.com/aubreykuang\\"}]}"],["meta",{"property":"og:url","content":"https://aubreykuang.github.io/blog/blog/se/BackEnd/%F0%9F%8C%9F%20java%E9%9B%86%E5%90%88/1%20%E5%9F%BA%E7%A1%80/2%20HashMap.html"}],["meta",{"property":"og:site_name","content":"Aubrey's Blog"}],["meta",{"property":"og:title","content":"HashMap"}],["meta",{"property":"og:description","content":"HashMap 高频面试题 1⃣️ 底层数据结构？ 1.7 数组 + 链表 数组和链表 结合在一起使用也就是 链表散列。 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。 1.8 数组 + 链表 ｜ 红黑树 （根据数据量多少而转换） 当链表长度大于阈值（默认为 8）时..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/3978/image-20230203153742311.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-04-26T09:43:18.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-26T09:43:18.000Z"}]]},"git":{"createdTime":1675481863000,"updatedTime":1682502198000,"contributors":[{"name":"KoryKL","username":"KoryKL","email":"1274994508@qq.com","commits":3,"url":"https://github.com/KoryKL"}]},"readingTime":{"minutes":2.52,"words":757},"filePathRelative":"se/BackEnd/🌟 java集合/1 基础/2 HashMap.md","excerpt":"\\n<h2>高频面试题</h2>\\n<h3>1⃣️ 底层数据结构？</h3>\\n<p>1.7 数组 + 链表</p>\\n<p><strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>\\n<p><strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>\\n<p>1.8 数组 + 链表 ｜ 红黑树 （根据数据量多少而转换）</p>\\n<p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p>","autoDesc":true}`);export{r as comp,g as data};
