import{_ as e,V as a,W as d,a0 as h}from"./framework-91a010c2.js";const r={},i=h('<h1 id="系统设计" tabindex="-1"><a class="header-anchor" href="#系统设计" aria-hidden="true">#</a> 系统设计</h1><h2 id="热点信息" tabindex="-1"><a class="header-anchor" href="#热点信息" aria-hidden="true">#</a> 热点信息</h2><p>在设计和开发时已经极力避免，然而在真实的生产环境中还是可能依旧存在的，导致其继续出现的原因有以下几种:</p><ul><li>有一些边界 case 没有考虑到</li><li>异常或非预期的流量</li></ul><h3 id="定位方案" tabindex="-1"><a class="header-anchor" href="#定位方案" aria-hidden="true">#</a> 定位方案</h3><p>从 Redis 请求路径上的节点来着手，比如在客户端、中间层和服务端</p><h4 id="客户端" tabindex="-1"><a class="header-anchor" href="#客户端" aria-hidden="true">#</a> 客户端</h4><p>改动 Redis SDK，记录每个请求，定时把收集到的数据上报，然后由一个统一的服务进行聚合计算。</p><p>方案直观简单，但没法适应多语言架构，一方面多语言 SDK 对齐是个问题，另外一方面后期 SDK 的维护升级会面临比较大的困难，成本很高。</p><h4 id="中间层" tabindex="-1"><a class="header-anchor" href="#中间层" aria-hidden="true">#</a> 中间层</h4><p>如果所有的 Redis 请求都经过代理的话，可以考虑改动 Proxy 代码进行收集，思路与客户端基本类似。该方案对使用方完全透明，能够解决客户端 SDK 的语言异构和版本升级问题，不过开发成本会比客户端高些。</p><h4 id="服务端" tabindex="-1"><a class="header-anchor" href="#服务端" aria-hidden="true">#</a> 服务端</h4><p>在可能存在热 key 的节点上(流量倾斜判断)，通过 tcpdump 抓取一段时间内的流量并上报，然后由一个外部的程序进行解析、聚合和计算。该方案无需侵入现有的 SDK 或者 Proxy 中间件，开发维护成本可控，但也存在缺点的，具体是热 key 节点的网络流量和系统负载已经比较高了，抓包可能会情况进一步恶化。</p><h3 id="如何处理热点" tabindex="-1"><a class="header-anchor" href="#如何处理热点" aria-hidden="true">#</a> 如何处理热点</h3><p>放在缓存中，最好可以写入 jvm （因为 jvm 中数据访问速度最快，几乎不存在网络开销），并且设置过期时间。</p><p>不宜写入太多，避免内存占用过大，要设置淘汰策略。</p><h2 id="静态资源" tabindex="-1"><a class="header-anchor" href="#静态资源" aria-hidden="true">#</a> 静态资源</h2><p>CDN（Content Delivery Network）内容分发网络</p><p>将静态资源分发到多个不同的地方以实现就近访问，加快静态资源的访问速度，减轻服务器及带宽的负担。</p><h2 id="高可用" tabindex="-1"><a class="header-anchor" href="#高可用" aria-hidden="true">#</a> 高可用</h2><p>保证系统中某个组件的高可用，往往需要搭建集群来避免单点风险，以 Redis 集群为例：</p><p>通过 异步复制，<strong>一主多从</strong> 来提高可用性和读吞吐量</p><p>问题：一旦 master 宕机，slave 晋升成 master，同时需要修改应用方的主节点地址，还需要命令所有从节点复制新的主节点。</p><p>解决：通过哨兵解决，监控 Redis 运行节点，当主节点故障，哨兵节点会帮助我们实现故障转移。整个过程完全自动，不需要人工介入</p><blockquote><p>哨兵其实是一个 Rdis 进程，只是不对外提供读写服务。</p></blockquote><h3 id="限流" tabindex="-1"><a class="header-anchor" href="#限流" aria-hidden="true">#</a> 限流</h3><p>接口限流：限制服务端的接口接受请求的频率</p><p>实现：可以直接用 Redis 基于 Lua 脚本做，也可以用现成的流量控制组件。组件往往会提供一些流量控制、熔断降级、系统自适应保护等功能。</p><p>用户、IP 限流：限制单位时间内请求接口的次数</p><blockquote><p>设置问题或者验证码，出了校验答案的正确性，还要校验用户的提交时间</p></blockquote><h3 id="流量削峰" tabindex="-1"><a class="header-anchor" href="#流量削峰" aria-hidden="true">#</a> 流量削峰</h3><p>对于突发的大流量，可以用消息队列</p><p>因为消息可以大量堆积在消息队列</p><h3 id="服务降级" tabindex="-1"><a class="header-anchor" href="#服务降级" aria-hidden="true">#</a> 服务降级</h3><p>从系统功能优先级的角度考虑应对系统故障</p><p>根据当前业务情况、流量对一些服务和页面有策略地降级，释放服务器资源以保证核心业务的正常运行。</p><blockquote><p>应对系统自身的故障</p></blockquote><h3 id="熔断" tabindex="-1"><a class="header-anchor" href="#熔断" aria-hidden="true">#</a> 熔断</h3><p>应对系统依赖的外部系统或者第三方系统的故障</p><h2 id="一致性" tabindex="-1"><a class="header-anchor" href="#一致性" aria-hidden="true">#</a> 一致性</h2><h3 id="减库存方案" tabindex="-1"><a class="header-anchor" href="#减库存方案" aria-hidden="true">#</a> 减库存方案</h3><p>下单即减库存</p><p>将秒杀商品的信息放到缓存中去，通过 Redis 对库存进行原子性操作</p><h3 id="接口幂等性" tabindex="-1"><a class="header-anchor" href="#接口幂等性" aria-hidden="true">#</a> 接口幂等性</h3><p>在分布式系统中，幂等是对请求操作结果的描述，就是不论执行多少次相同的请求，产生的效果和返回的结果都和发出单个请求一样。</p><p>前端要做、后端也要做</p><p>前端：当用户提交请求后将按钮变灰</p><p>后端：同步锁、分布式锁、业务字段唯一索引约束</p><blockquote><p>分布式锁：加锁的方式，限制用户在第一次请求未结束之前，无法进行第二次请求</p></blockquote><h2 id="feed-流-信息流" tabindex="-1"><a class="header-anchor" href="#feed-流-信息流" aria-hidden="true">#</a> Feed 流 / 信息流</h2><p>TimeLine 时期，基于时间</p><p>现在的 Feed 流主要基于个性化推荐</p><h3 id="feed-流" tabindex="-1"><a class="header-anchor" href="#feed-流" aria-hidden="true">#</a> Feed 流</h3><p>实时 / 智能推送信息的数据流，朋友圈动态、平台推荐等都属于 Feed 流</p><h4 id="三种形式" tabindex="-1"><a class="header-anchor" href="#三种形式" aria-hidden="true">#</a> 三种形式</h4><ol><li>纯智能推荐，依赖推荐系统</li><li>时间线，微信朋友圈</li><li>智能推荐 + 时间线</li></ol><h4 id="三种推送模式" tabindex="-1"><a class="header-anchor" href="#三种推送模式" aria-hidden="true">#</a> 三种推送模式</h4><p>推模式：博主更新后，推给粉丝</p><p>拉模式：自己拉取动态</p><blockquote><p>虽然拉模式的存储成本低，但是查询和聚合的成本高。实时性比推模式差</p></blockquote><p>推拉结合：微博大 V 和不活跃用户</p><blockquote><p>适用于用户粉丝数大的场景</p><p><img src="https://cdn.jsdelivr.net/gh/KoryKL/pictures@main/blog/image-20230412170318569.png" alt="image-20230412170318569" loading="lazy"></p></blockquote><h3 id="存储" tabindex="-1"><a class="header-anchor" href="#存储" aria-hidden="true">#</a> 存储</h3><p>MySQL 永久保存数据</p><p>Redis 作为缓存，提高热点数据的访问速度</p><blockquote><p>如果缓存的数据量太大，可以用 Redis 集群</p></blockquote><p>提高系统的并发，可以 读写分离 、 分库分表</p><blockquote><p>读写分离：数据库的读和写操作分到不同的数据库节点上。主服务器负责写，从服务器负责读。可以大幅提高读性能，小幅提高写性能。</p></blockquote>',68),p=[i];function t(n,c){return a(),d("div",null,p)}const s=e(r,[["render",t],["__file","4 系统设计.html.vue"]]);export{s as default};
