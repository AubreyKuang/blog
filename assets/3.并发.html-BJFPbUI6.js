import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as s,o as t}from"./app-fVbzsCFO.js";const n={};function r(o,e){return t(),i("div",null,e[0]||(e[0]=[s(`<h1 id="并发" tabindex="-1"><a class="header-anchor" href="#并发"><span>并发</span></a></h1><h2 id="并发引发的问题" tabindex="-1"><a class="header-anchor" href="#并发引发的问题"><span>并发引发的问题</span></a></h2><h3 id="_1⃣️-脏读" tabindex="-1"><a class="header-anchor" href="#_1⃣️-脏读"><span>1⃣️ 脏读</span></a></h3><p>一个事务读取到另一个未提交事务修改的数据</p><blockquote><p>因为这个修改数据的事务还没提交，可能发生回滚。如果回滚，读取数据的事务得到的就是过期数据。</p></blockquote><h3 id="_2⃣️-不可重复读" tabindex="-1"><a class="header-anchor" href="#_2⃣️-不可重复读"><span>2⃣️ 不可重复读</span></a></h3><p>一个事务内多次读取同一条记录，但是两次读取的数据不同</p><blockquote><p>例如：一个事务查询两次，另一个事务在中间的时候update</p></blockquote><h3 id="_3⃣️-幻读" tabindex="-1"><a class="header-anchor" href="#_3⃣️-幻读"><span>3⃣️ 幻读</span></a></h3><p>一个事务按照条件查询数据时，没有对应的数据行，但是插入时已经存在</p><p>多次查询某个符合查询条件的「记录数量」，出现前后两次查询到的记录数量不一样的情况。</p><blockquote><p>例如：一个事务先查后增，另一个事务同时增</p></blockquote><h2 id="事务隔离级别" tabindex="-1"><a class="header-anchor" href="#事务隔离级别"><span>事务隔离级别</span></a></h2><p>较高的隔离级别牺牲性能</p><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读已提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>序列化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><blockquote><p>Oracle数据库的默认：Read committed</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405163827139.png" alt="image-20230405163827139"></p><p><strong>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象</strong></p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务<strong>启动时看到的数据是一致的</strong>。即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个<strong>插入语句就会被阻塞</strong>，无法成功插入，所以就很好了避免幻读问题。</li></ul><div class="language-sql line-numbers-mode" data-highlighter="shiki" data-ext="sql" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code class="language-sql"><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 查看事务隔离级别</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SELECT</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">@@TRANSACTION_ISOLATION;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">-- 设置事务隔离级别</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">SET</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">[SESSION|GLOBAL]</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">TRANSACTION</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> ISOLATION</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> LEVER {</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">READ</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> UNCOMMITTED</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">|...}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="隔离级别的实现" tabindex="-1"><a class="header-anchor" href="#隔离级别的实现"><span>隔离级别的实现</span></a></h3><ul><li><p>对于「读未提交」隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</p></li><li><p>对于「串行化」隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</p></li><li><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的<strong>区别在于创建 Read View 的时机不同</strong></p><p>「读提交」隔离级别是在「**每个语句执行前」**都会重新生成一个 Read View，</p><p>「可重复读」隔离级别是「启动事务时」生成一个 Read View，然后整个事务期间都在用这个 Read View。</p></li></ul><h2 id="在mvcc的工作" tabindex="-1"><a class="header-anchor" href="#在mvcc的工作"><span>在MVCC的工作？</span></a></h2><h3 id="readview重要字段" tabindex="-1"><a class="header-anchor" href="#readview重要字段"><span>ReadView重要字段</span></a></h3><p>四个重要字段</p><p><img src="https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405164929550.png" alt="image-20230405164929550"></p><h3 id="聚簇索引的两个隐藏列" tabindex="-1"><a class="header-anchor" href="#聚簇索引的两个隐藏列"><span>聚簇索引的两个隐藏列</span></a></h3><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p><p><img src="https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405165926485.png" alt="image-20230405165926485"></p><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 trx_id 是否在 m_ids 列表中： <ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p><h2 id="mvcc" tabindex="-1"><a class="header-anchor" href="#mvcc"><span>MVCC</span></a></h2><h3 id="可重复读" tabindex="-1"><a class="header-anchor" href="#可重复读"><span>可重复读</span></a></h3><p><strong>第一次快照读时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p>在事务期间读到的记录都是事务启动前的记录</p><h3 id="读提交" tabindex="-1"><a class="header-anchor" href="#读提交"><span>读提交</span></a></h3><p><strong>在每次快照读时，都会生成一个新的 Read View</strong>。</p><p>在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><p>对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：</p><ul><li>「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</li><li>「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。</li></ul><p>这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p><p>在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。</p><h2 id="可重复读不能解决幻读的情况" tabindex="-1"><a class="header-anchor" href="#可重复读不能解决幻读的情况"><span>可重复读不能解决幻读的情况</span></a></h2><h3 id="可以解决的原理" tabindex="-1"><a class="header-anchor" href="#可以解决的原理"><span>可以解决的原理</span></a></h3><p>执行第一个查询语句后，会创建一个 Read View，<strong>后续的查询语句利用这个 Read View，通过这个 Read View 就可以在 undo log 版本链找到事务开始时的数据，所以事务过程中每次查询的数据都是一样的</strong>，即使中途有其他事务插入了新纪录，是查询不出来这条数据的，所以就很好了避免幻读问题。</p><h3 id="不能的情况" tabindex="-1"><a class="header-anchor" href="#不能的情况"><span>不能的情况</span></a></h3><p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为<strong>当事务 A 更新了一条事务 B 插入的记录</strong>，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p><p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而<strong>是先快照读</strong>，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p><p>要避免这类特殊场景下发生幻读的现象的话，就是尽量在开启事务之后，马上执行 select ... for update 这类当前读的语句，因为它会对记录加 next-key lock，从而避免其他事务插入一条新记录。</p>`,51)]))}const d=a(n,[["render",r]]),h=JSON.parse(`{"path":"/cs/database/mysql/%F0%9F%93%93%201%20%E4%BA%8B%E5%8A%A1/3.%E5%B9%B6%E5%8F%91.html","title":"并发","lang":"en-US","frontmatter":{"description":"并发 并发引发的问题 1⃣️ 脏读 一个事务读取到另一个未提交事务修改的数据 因为这个修改数据的事务还没提交，可能发生回滚。如果回滚，读取数据的事务得到的就是过期数据。 2⃣️ 不可重复读 一个事务内多次读取同一条记录，但是两次读取的数据不同 例如：一个事务查询两次，另一个事务在中间的时候update 3⃣️ 幻读 一个事务按照条件查询数据时，没有对应...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"并发\\",\\"image\\":[\\"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405163827139.png\\",\\"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405164929550.png\\",\\"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405165926485.png\\"],\\"dateModified\\":\\"2025-08-18T03:49:31.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aubrey\\",\\"url\\":\\"https://github.com/aubreykuang\\"}]}"],["meta",{"property":"og:url","content":"https://aubreykuang.github.io/blog/blog/cs/database/mysql/%F0%9F%93%93%201%20%E4%BA%8B%E5%8A%A1/3.%E5%B9%B6%E5%8F%91.html"}],["meta",{"property":"og:site_name","content":"Aubrey's Blog"}],["meta",{"property":"og:title","content":"并发"}],["meta",{"property":"og:description","content":"并发 并发引发的问题 1⃣️ 脏读 一个事务读取到另一个未提交事务修改的数据 因为这个修改数据的事务还没提交，可能发生回滚。如果回滚，读取数据的事务得到的就是过期数据。 2⃣️ 不可重复读 一个事务内多次读取同一条记录，但是两次读取的数据不同 例如：一个事务查询两次，另一个事务在中间的时候update 3⃣️ 幻读 一个事务按照条件查询数据时，没有对应..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://cdn.jsdelivr.net/gh/AubreyKuang/pictures@main/blog/image-20230405163827139.png"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2025-08-18T03:49:31.000Z"}],["meta",{"property":"article:modified_time","content":"2025-08-18T03:49:31.000Z"}]]},"git":{"createdTime":1672758980000,"updatedTime":1755488971000,"contributors":[{"name":"KoryKL","username":"KoryKL","email":"1274994508@qq.com","commits":3,"url":"https://github.com/KoryKL"},{"name":"kory","username":"kory","email":"apple@kuangyongbeideMacBook-Air.local","commits":1,"url":"https://github.com/kory"}]},"readingTime":{"minutes":7.3,"words":2189},"filePathRelative":"cs/database/mysql/📓 1 事务/3.并发.md","excerpt":"\\n<h2>并发引发的问题</h2>\\n<h3>1⃣️ 脏读</h3>\\n<p>一个事务读取到另一个未提交事务修改的数据</p>\\n<blockquote>\\n<p>因为这个修改数据的事务还没提交，可能发生回滚。如果回滚，读取数据的事务得到的就是过期数据。</p>\\n</blockquote>\\n<h3>2⃣️ 不可重复读</h3>\\n<p>一个事务内多次读取同一条记录，但是两次读取的数据不同</p>\\n<blockquote>\\n<p>例如：一个事务查询两次，另一个事务在中间的时候update</p>\\n</blockquote>\\n<h3>3⃣️ 幻读</h3>\\n<p>一个事务按照条件查询数据时，没有对应的数据行，但是插入时已经存在</p>","autoDesc":true}`);export{d as comp,h as data};
