import{_ as p}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a,o as n}from"./app-fVbzsCFO.js";const o={};function r(s,e){return n(),t("div",null,e[0]||(e[0]=[a('<h1 id="mysql执行流程" tabindex="-1"><a class="header-anchor" href="#mysql执行流程"><span>MySQL执行流程</span></a></h1><p>MySQL的架构分为：Sever层和存储引擎层</p><ol><li><p>Sever层：建立连接、分析、执行SQL</p><p>大多数核心功能模块都在这实现（查询缓存、执行器、所有的内置函数、跨存储引擎的操作）</p></li><li><p>存储引擎层：数据的存储和提取</p><p>不同的存储引擎共用一个Sever层</p></li></ol><h2 id="_1-连接器" tabindex="-1"><a class="header-anchor" href="#_1-连接器"><span>1. 连接器</span></a></h2><p>连接MySQL服务，经过TCP三次握手</p><p>校验客户端的账号密码</p><p>如果账号密码正确，就会读取用户权限，后面的权限逻辑判断都基于此时的逻辑</p><blockquote><p>MySQL基于TCP协议传输</p><p>空闲连接不会一直占用，MySQL定义了连接的最大空闲时长，如果超过了就会自动断开（也可以手动断开</p><p>MySQL默认服务是151个，如果超过，就会拒绝接下来的连接请求</p><p>也有长连接，短连接：使用长连接的好处就是可以<strong>减少建立连接和断开连接</strong>的过程；但是，使用长连接后可能会<strong>占用内存增多</strong>，因为 MySQL 在执行查询过程中临时<strong>使用内存</strong>管理连接对象，这些连接对象资源只有在连接<strong>断开时才会释放</strong>。</p><p>解决长连接占用：1. 定期断开长连接 2. 客户端主动重置连接</p></blockquote><h2 id="_2-查询缓存" tabindex="-1"><a class="header-anchor" href="#_2-查询缓存"><span>2. 查询缓存</span></a></h2><p>解析SQL语句第一个字段</p><p>如果是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache ）里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中</p><p>如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。</p><p>MySQL 8.0 后已经删除这个模块</p><blockquote><p>命中率很低，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。</p></blockquote><h2 id="_3-解析sql" tabindex="-1"><a class="header-anchor" href="#_3-解析sql"><span>3. 解析SQL</span></a></h2><p>正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成</p><ol><li><p>词法分析</p><p>根据数据的字符串，提取关键词</p></li><li><p>语法分析</p><p>判断是否符合MySQL语法，如果语法不对，会在这个阶段报错</p></li></ol><p>方便后续模块读取表名、字段、语句类型；</p><h2 id="_4-执行sql" tabindex="-1"><a class="header-anchor" href="#_4-执行sql"><span>4. 执行SQL</span></a></h2><p>每条<code>SELECT</code> 查询语句流程主要可以分为下面这三个阶段：</p><h3 id="预处理" tabindex="-1"><a class="header-anchor" href="#预处理"><span>预处理</span></a></h3><ol><li>检查查询语句中的表或者字段是否存在</li><li>将select*拓展为所有列</li></ol><h3 id="优化器" tabindex="-1"><a class="header-anchor" href="#优化器"><span>优化器</span></a></h3><p>确定SQL查询语句的执行方案，比如有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><h3 id="执行器" tabindex="-1"><a class="header-anchor" href="#执行器"><span>执行器</span></a></h3><p>根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</p><ol><li><p>主键索引查询</p></li><li><p>全表扫描</p></li><li><p>索引下推</p><p>减少<strong>二级索引</strong>在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。</p><blockquote><p>MySQL 5.6 推出的查询优化策略</p></blockquote></li></ol><h2 id="count" tabindex="-1"><a class="header-anchor" href="#count"><span>count(*)</span></a></h2><p><strong>其实等于 count(<code>0</code>)</strong>，也就是说，当你使用 count(<code>*</code>) 时，MySQL 会将 <code>*</code> 参数转化为参数 0 来处理。</p><p>只有主键索引，没有二级索引：InnoDB 循环遍历聚簇索引（主键索引），将读取到的记录返回给 server 层，<strong>但是不会读取记录中的任何字段的值</strong>，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。参数 1 很明显并不是 NULL，因此 server 层每从 InnoDB 读取到一条记录，就将 count 变量加 1。</p><h3 id="count-字段" tabindex="-1"><a class="header-anchor" href="#count-字段"><span>count(字段)</span></a></h3><p>执行效率最差，全表扫描</p><h3 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h3><ol><li><p>近似值，例如搜索引擎给出的大约有多少条结果</p><p>show table status或者explain</p><p>执行 explain 命令效率是很高的，因为它并不会真正的去查询</p></li><li><p>额外表保存计数值</p><p>如果是想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。</p><p>当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。</p></li></ol>',34)]))}const i=p(o,[["render",r]]),h=JSON.parse(`{"path":"/cs/database/mysql/%F0%9F%93%93%204%20SQL%E4%BC%98%E5%8C%96/0%20MySQL%E6%89%A7%E8%A1%8C.html","title":"MySQL执行流程","lang":"en-US","frontmatter":{"description":"MySQL执行流程 MySQL的架构分为：Sever层和存储引擎层 Sever层：建立连接、分析、执行SQL 大多数核心功能模块都在这实现（查询缓存、执行器、所有的内置函数、跨存储引擎的操作） 存储引擎层：数据的存储和提取 不同的存储引擎共用一个Sever层 1. 连接器 连接MySQL服务，经过TCP三次握手 校验客户端的账号密码 如果账号密码正确，...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"MySQL执行流程\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-04-06T03:21:04.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Aubrey\\",\\"url\\":\\"https://github.com/aubreykuang\\"}]}"],["meta",{"property":"og:url","content":"https://aubreykuang.github.io/blog/blog/cs/database/mysql/%F0%9F%93%93%204%20SQL%E4%BC%98%E5%8C%96/0%20MySQL%E6%89%A7%E8%A1%8C.html"}],["meta",{"property":"og:site_name","content":"Aubrey's Blog"}],["meta",{"property":"og:title","content":"MySQL执行流程"}],["meta",{"property":"og:description","content":"MySQL执行流程 MySQL的架构分为：Sever层和存储引擎层 Sever层：建立连接、分析、执行SQL 大多数核心功能模块都在这实现（查询缓存、执行器、所有的内置函数、跨存储引擎的操作） 存储引擎层：数据的存储和提取 不同的存储引擎共用一个Sever层 1. 连接器 连接MySQL服务，经过TCP三次握手 校验客户端的账号密码 如果账号密码正确，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"en-US"}],["meta",{"property":"og:updated_time","content":"2023-04-06T03:21:04.000Z"}],["meta",{"property":"article:modified_time","content":"2023-04-06T03:21:04.000Z"}]]},"git":{"createdTime":1679577491000,"updatedTime":1680751264000,"contributors":[{"name":"KoryKL","username":"KoryKL","email":"1274994508@qq.com","commits":2,"url":"https://github.com/KoryKL"}]},"readingTime":{"minutes":3.84,"words":1152},"filePathRelative":"cs/database/mysql/📓 4 SQL优化/0 MySQL执行.md","excerpt":"\\n<p>MySQL的架构分为：Sever层和存储引擎层</p>\\n<ol>\\n<li>\\n<p>Sever层：建立连接、分析、执行SQL</p>\\n<p>大多数核心功能模块都在这实现（查询缓存、执行器、所有的内置函数、跨存储引擎的操作）</p>\\n</li>\\n<li>\\n<p>存储引擎层：数据的存储和提取</p>\\n<p>不同的存储引擎共用一个Sever层</p>\\n</li>\\n</ol>\\n<h2>1. 连接器</h2>\\n<p>连接MySQL服务，经过TCP三次握手</p>\\n<p>校验客户端的账号密码</p>\\n<p>如果账号密码正确，就会读取用户权限，后面的权限逻辑判断都基于此时的逻辑</p>\\n<blockquote>\\n<p>MySQL基于TCP协议传输</p>\\n<p>空闲连接不会一直占用，MySQL定义了连接的最大空闲时长，如果超过了就会自动断开（也可以手动断开</p>\\n<p>MySQL默认服务是151个，如果超过，就会拒绝接下来的连接请求</p>\\n<p>也有长连接，短连接：使用长连接的好处就是可以<strong>减少建立连接和断开连接</strong>的过程；但是，使用长连接后可能会<strong>占用内存增多</strong>，因为 MySQL 在执行查询过程中临时<strong>使用内存</strong>管理连接对象，这些连接对象资源只有在连接<strong>断开时才会释放</strong>。</p>\\n<p>解决长连接占用：1. 定期断开长连接 2. 客户端主动重置连接</p>\\n</blockquote>","autoDesc":true}`);export{i as comp,h as data};
